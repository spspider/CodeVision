
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001c30  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00001c30  00001ce4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000032a  00800090  00800090  00001d14  2**0
                  ALLOC
  3 .eeprom       00000022  00810000  00810000  00001d14  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000080  00000000  00000000  00001d36  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000005c2  00000000  00000000  00001db6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001ffe  00000000  00000000  00002378  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008b5  00000000  00000000  00004376  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d13  00000000  00000000  00004c2b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000390  00000000  00000000  00006940  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006d0  00000000  00000000  00006cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001080  00000000  00000000  000073a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00008420  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	60 c2       	rjmp	.+1216   	; 0x4c2 <__ctors_end>
       2:	7a c2       	rjmp	.+1268   	; 0x4f8 <__bad_interrupt>
       4:	79 c2       	rjmp	.+1266   	; 0x4f8 <__bad_interrupt>
       6:	78 c2       	rjmp	.+1264   	; 0x4f8 <__bad_interrupt>
       8:	77 c2       	rjmp	.+1262   	; 0x4f8 <__bad_interrupt>
       a:	76 c2       	rjmp	.+1260   	; 0x4f8 <__bad_interrupt>
       c:	75 c2       	rjmp	.+1258   	; 0x4f8 <__bad_interrupt>
       e:	74 c2       	rjmp	.+1256   	; 0x4f8 <__bad_interrupt>
      10:	80 c2       	rjmp	.+1280   	; 0x512 <__vector_8>
      12:	72 c2       	rjmp	.+1252   	; 0x4f8 <__bad_interrupt>
      14:	71 c2       	rjmp	.+1250   	; 0x4f8 <__bad_interrupt>
      16:	70 c2       	rjmp	.+1248   	; 0x4f8 <__bad_interrupt>
      18:	6f c2       	rjmp	.+1246   	; 0x4f8 <__bad_interrupt>
      1a:	6e c2       	rjmp	.+1244   	; 0x4f8 <__bad_interrupt>
      1c:	6d c2       	rjmp	.+1242   	; 0x4f8 <__bad_interrupt>
      1e:	6c c2       	rjmp	.+1240   	; 0x4f8 <__bad_interrupt>
      20:	6b c2       	rjmp	.+1238   	; 0x4f8 <__bad_interrupt>
      22:	6a c2       	rjmp	.+1236   	; 0x4f8 <__bad_interrupt>
      24:	69 c2       	rjmp	.+1234   	; 0x4f8 <__bad_interrupt>

00000026 <__c.2013>:
      26:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
      36:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
      46:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 20 3c 64 69     ext/html.... <di
      56:	76 20 41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e c2     v ALIGN=CENTER>.
      66:	fb 20 ed e5 20 e2 e2 e5 eb e8 20 ef e0 f0 ee eb     . .. ..... .....
      76:	fc 00                                               ..

00000078 <__c.2011>:
      78:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
      88:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
      98:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 20 3c 64 69     ext/html.... <di
      a8:	76 20 41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e c2     v ALIGN=CENTER>.
      b8:	fb 20 e2 e2 e5 eb e8 20 ed e5 e2 e5 f0 ed fb e9     . ..... ........
      c8:	20 ef e0 f0 ee eb fc 00                              .......

000000d0 <__c.2009>:
      d0:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
      e0:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
      f0:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 20 3c 64 69     ext/html.... <di
     100:	76 20 41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e c2     v ALIGN=CENTER>.
     110:	fb 20 e2 e2 e5 eb e8 20 ed e5 e2 e5 f0 ed fb e9     . ..... ........
     120:	20 ef e0 f0 ee eb fc 00                              .......

00000128 <__c.2006>:
     128:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     138:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     148:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 3c 64 69 76     ext/html....<div
     158:	20 41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e 20 c2      ALIGN=CENTER> .
     168:	f1 e5 20 ce ca 00                                   .. ...

0000016e <__c.2004>:
     16e:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     17e:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     18e:	65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 00              ext/html.....

0000019b <__c.1917>:
     19b:	3c 62 72 3e 3c 2f 69 3e 3c 2f 62 6f 64 79 3e 00     <br></i></body>.

000001ab <__c.1915>:
     1ab:	3e 3c 62 72 3e 3c 62 72 3e cf e0 f0 ee eb fc 20     ><br><br>...... 
     1bb:	26 6e 62 73 70 3c 69 6e 70 75 74 20 74 79 70 65     &nbsp<input type
     1cb:	3d 70 61 73 73 77 6f 72 64 20 6e 61 6d 65 3d 70     =password name=p
     1db:	77 3e 0a 20 26 6e 62 73 70 20 26 6e 62 73 70 3c     w>. &nbsp &nbsp<
     1eb:	69 6e 70 75 74 20 74 79 70 65 3d 73 75 62 6d 69     input type=submi
     1fb:	74 20 76 61 6c 75 65 3d ee f2 ef f0 e0 e2 e8 f2     t value=........
     20b:	fc 20 3e 3c 2f 66 6f 72 6d 3e 0a 00                 . ></form>..

00000217 <__c.1913>:
     217:	3e 3c 62 72 3e 3c 62 72 3e 20 4d 61 63 20 d8 eb     ><br><br> Mac ..
     227:	fe e7 e0 20 26 6e 62 73 70 3c 69 6e 70 75 74 20     ... &nbsp<input 
     237:	74 79 70 65 3d 74 65 78 74 20 20 76 61 6c 75 65     type=text  value
     247:	3d 00                                               =.

00000249 <__c.1911>:
     249:	3e 3c 62 72 3e 3c 62 72 3e 20 cc e0 f1 ea e0 20     ><br><br> ..... 
     259:	ef ee e4 f1 e5 f2 e8 20 26 6e 62 73 70 3c 69 6e     ....... &nbsp<in
     269:	70 75 74 20 74 79 70 65 3d 74 65 78 74 20 6e 61     put type=text na
     279:	6d 65 3d 6d 73 20 76 61 6c 75 65 3d 00              me=ms value=.

00000286 <__c.1909>:
     286:	3e 3c 62 72 3e 3c 62 72 3e 49 50 20 d8 eb fe e7     ><br><br>IP ....
     296:	e0 20 20 26 6e 62 73 70 3c 69 6e 70 75 74 20 74     .  &nbsp<input t
     2a6:	79 70 65 3d 74 65 78 74 20 6e 61 6d 65 3d 67 77     ype=text name=gw
     2b6:	20 76 61 6c 75 65 3d 00                              value=.

000002be <__c.1906>:
     2be:	3c 62 72 3e 3c 62 72 3e 3c 62 72 3e 3c 62 72 3e     <br><br><br><br>
     2ce:	3c 62 72 3e 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     <br><form action
     2de:	3d 2f 66 6f 72 6d 20 6d 65 74 68 6f 64 3d 67 65     =/form method=ge
     2ee:	74 3e 3c 64 69 76 20 41 4c 49 47 4e 3d 43 45 4e     t><div ALIGN=CEN
     2fe:	54 45 52 3e 20 cd ee e2 fb e9 20 49 50 20 26 6e     TER> ..... IP &n
     30e:	62 73 70 20 3c 69 6e 70 75 74 20 74 79 70 65 3d     bsp <input type=
     31e:	74 65 78 74 20 6e 61 6d 65 3d 69 70 20 76 61 6c     text name=ip val
     32e:	75 65 3d 00                                         ue=.

00000332 <__c.1887>:
     332:	3c 62 72 3e 3c 2f 69 3e 3c 2f 62 6f 64 79 3e 00     <br></i></body>.

00000342 <__c.1885>:
     342:	3c 62 72 3e 3c 62 72 3e 3c 62 72 3e 3c 62 72 3e     <br><br><br><br>
     352:	3c 62 72 3e 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     <br><form action
     362:	3d 2f 63 6f 6e 66 69 67 20 6d 65 74 68 6f 64 3d     =/config method=
     372:	67 65 74 3e 3c 64 69 76 20 41 4c 49 47 4e 3d 43     get><div ALIGN=C
     382:	45 4e 54 45 52 3e cf e5 f0 e5 f5 ee e4 20 ed e0     ENTER>....... ..
     392:	20 f1 f2 f0 e0 ed e8 f6 f3 20 ea ee ed f4 e8 e3      ........ ......
     3a2:	f3 f0 e0 f6 e8 e8 20 26 6e 62 73 70 20 26 6e 62     ...... &nbsp &nb
     3b2:	73 70 3c 69 6e 70 75 74 20 74 79 70 65 3d 73 75     sp<input type=su
     3c2:	62 6d 69 74 20 76 61 6c 75 65 3d cf e5 f0 e5 e9     bmit value=.....
     3d2:	f2 e8 20 3e 3c 2f 66 6f 72 6d 3e 0a 00              .. ></form>..

000003df <__c.1883>:
     3df:	3c 64 69 76 20 41 4c 49 47 4e 3d 43 45 4e 54 45     <div ALIGN=CENTE
     3ef:	52 3e 3c 62 72 3e d2 e5 ec ef e5 f0 e0 f2 f3 f0     R><br>..........
     3ff:	e0 20 3a 20 00                                      . : .

00000404 <__c.1881>:
     404:	20 c4 e0 f2 f7 e8 ea 20 ed e5 20 ed e0 e9 e4 e5      ...... .. .....
     414:	ed 20 3c 62 72 3e 3c 62 72 3e 3c 62 72 3e 20 20     . <br><br><br>  
     424:	3c 2f 69 3e 3c 2f 62 6f 64 79 3e 00                 </i></body>.

00000430 <__c.1879>:
     430:	3c 68 65 61 64 3e 3c 4d 45 54 41 20 48 54 54 50     <head><META HTTP
     440:	2d 45 51 55 49 56 3d 52 45 46 52 45 53 48 20 43     -EQUIV=REFRESH C
     450:	4f 4e 54 45 4e 54 3d 33 3e 3c 74 69 74 6c 65 3e     ONTENT=3><title>
     460:	d2 e5 f0 ec ee f1 e5 f0 e2 e5 f0 3c 2f 74 69 74     ...........</tit
     470:	6c 65 3e 3c 2f 68 65 61 64 3e 3c 62 6f 64 79 3e     le></head><body>
     480:	3c 64 69 76 20 41 4c 49 47 4e 3d 43 45 4e 54 45     <div ALIGN=CENTE
     490:	52 3e 3c 69 3e 3c 70 72 65 3e 3c 68 31 3e d2 c5     R><i><pre><h1>..
     4a0:	d0 cc ce d1 c5 d0 c2 c5 d0 3c 2f 70 72 65 3e 3c     .........</pre><
     4b0:	2f 68 31 3e 3c 62 72 3e 00                          /h1><br>.

000004b9 <arpreqhdr>:
     4b9:	00 01 08 00 06 04 00 01 00                          .........

000004c2 <__ctors_end>:
     4c2:	11 24       	eor	r1, r1
     4c4:	1f be       	out	0x3f, r1	; 63
     4c6:	cf e5       	ldi	r28, 0x5F	; 95
     4c8:	d4 e0       	ldi	r29, 0x04	; 4
     4ca:	de bf       	out	0x3e, r29	; 62
     4cc:	cd bf       	out	0x3d, r28	; 61

000004ce <__do_copy_data>:
     4ce:	10 e0       	ldi	r17, 0x00	; 0
     4d0:	a0 e6       	ldi	r26, 0x60	; 96
     4d2:	b0 e0       	ldi	r27, 0x00	; 0
     4d4:	e0 e3       	ldi	r30, 0x30	; 48
     4d6:	fc e1       	ldi	r31, 0x1C	; 28
     4d8:	02 c0       	rjmp	.+4      	; 0x4de <.do_copy_data_start>

000004da <.do_copy_data_loop>:
     4da:	05 90       	lpm	r0, Z+
     4dc:	0d 92       	st	X+, r0

000004de <.do_copy_data_start>:
     4de:	a0 39       	cpi	r26, 0x90	; 144
     4e0:	b1 07       	cpc	r27, r17
     4e2:	d9 f7       	brne	.-10     	; 0x4da <.do_copy_data_loop>

000004e4 <__do_clear_bss>:
     4e4:	13 e0       	ldi	r17, 0x03	; 3
     4e6:	a0 e9       	ldi	r26, 0x90	; 144
     4e8:	b0 e0       	ldi	r27, 0x00	; 0
     4ea:	01 c0       	rjmp	.+2      	; 0x4ee <.do_clear_bss_start>

000004ec <.do_clear_bss_loop>:
     4ec:	1d 92       	st	X+, r1

000004ee <.do_clear_bss_start>:
     4ee:	aa 3b       	cpi	r26, 0xBA	; 186
     4f0:	b1 07       	cpc	r27, r17
     4f2:	e1 f7       	brne	.-8      	; 0x4ec <.do_clear_bss_loop>
     4f4:	49 d2       	rcall	.+1170   	; 0x988 <main>
     4f6:	9a cb       	rjmp	.-2252   	; 0xfffffc2c <__eeprom_end+0xff7efc0a>

000004f8 <__bad_interrupt>:
     4f8:	83 cd       	rjmp	.-1274   	; 0x0 <__vectors>

000004fa <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     4fa:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     4fc:	e1 99       	sbic	0x1c, 1	; 28
     4fe:	fe cf       	rjmp	.-4      	; 0x4fc <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     500:	3f bb       	out	0x1f, r19	; 31
     502:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
     504:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	f8 94       	cli
     50a:	e2 9a       	sbi	0x1c, 2	; 28
     50c:	e1 9a       	sbi	0x1c, 1	; 28
     50e:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     510:	08 95       	ret

00000512 <__vector_8>:
int t;						            // вспомогательные переменные
char rr[9];
volatile uint8_t time=0; 
// прерывание по таймеру	
 ISR(TIMER1_OVF_vect)
 {
     512:	1f 92       	push	r1
     514:	0f 92       	push	r0
     516:	0f b6       	in	r0, 0x3f	; 63
     518:	0f 92       	push	r0
     51a:	11 24       	eor	r1, r1
     51c:	8f 93       	push	r24
 time++; //  увеличиваем счетчик
     51e:	80 91 90 00 	lds	r24, 0x0090
     522:	8f 5f       	subi	r24, 0xFF	; 255
     524:	80 93 90 00 	sts	0x0090, r24
 } 
     528:	8f 91       	pop	r24
     52a:	0f 90       	pop	r0
     52c:	0f be       	out	0x3f, r0	; 63
     52e:	0f 90       	pop	r0
     530:	1f 90       	pop	r1
     532:	18 95       	reti

00000534 <find_key_val>:
 // ищем ключи если нашли копируем содержимое полей в буфер
 // добавляем в конце NULL
 // если поле заполнено возврвщаем 1
 // возвращаем количество проинятых символов
uint8_t find_key_val(char *str,char *strbuf, uint8_t maxlen,char *key)   // ищем ключевые слова
{
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	dc 01       	movw	r26, r24
     53a:	eb 01       	movw	r28, r22
     53c:	72 2f       	mov	r23, r18
     53e:	63 2f       	mov	r22, r19
     540:	82 2f       	mov	r24, r18
     542:	93 2f       	mov	r25, r19
     544:	9c 01       	movw	r18, r24
     546:	f9 01       	movw	r30, r18
     548:	50 e0       	ldi	r21, 0x00	; 0
     54a:	16 c0       	rjmp	.+44     	; 0x578 <find_key_val+0x44>
    uint8_t found=0;
        uint8_t i=0;
        char *kp;
        kp=key;
        while(*str &&  *str!=' ' && *str!='\n' && found==0){
                if (*str == *kp){
     54c:	80 81       	ld	r24, Z
     54e:	98 17       	cp	r25, r24
     550:	71 f4       	brne	.+28     	; 0x56e <find_key_val+0x3a>
                        kp++;
     552:	31 96       	adiw	r30, 0x01	; 1
                        if (*kp == '\0'){
     554:	80 81       	ld	r24, Z
     556:	88 23       	and	r24, r24
     558:	71 f4       	brne	.+28     	; 0x576 <find_key_val+0x42>
                                str++;
     55a:	11 96       	adiw	r26, 0x01	; 1
                                kp=key;
                                if (*str == '='){
     55c:	8c 91       	ld	r24, X
     55e:	8d 33       	cpi	r24, 0x3D	; 61
     560:	31 f4       	brne	.+12     	; 0x56e <find_key_val+0x3a>
     562:	87 2f       	mov	r24, r23
     564:	96 2f       	mov	r25, r22
     566:	9c 01       	movw	r18, r24
     568:	f9 01       	movw	r30, r18
     56a:	51 e0       	ldi	r21, 0x01	; 1
     56c:	04 c0       	rjmp	.+8      	; 0x576 <find_key_val+0x42>
     56e:	87 2f       	mov	r24, r23
     570:	96 2f       	mov	r25, r22
     572:	9c 01       	movw	r18, r24
     574:	f9 01       	movw	r30, r18
                                }
                        }
                }else{
                        kp=key;
                }
                str++;
     576:	11 96       	adiw	r26, 0x01	; 1
{
    uint8_t found=0;
        uint8_t i=0;
        char *kp;
        kp=key;
        while(*str &&  *str!=' ' && *str!='\n' && found==0){
     578:	9c 91       	ld	r25, X
     57a:	99 23       	and	r25, r25
     57c:	39 f0       	breq	.+14     	; 0x58c <find_key_val+0x58>
     57e:	90 32       	cpi	r25, 0x20	; 32
     580:	29 f0       	breq	.+10     	; 0x58c <find_key_val+0x58>
     582:	9a 30       	cpi	r25, 0x0A	; 10
     584:	19 f0       	breq	.+6      	; 0x58c <find_key_val+0x58>
     586:	55 23       	and	r21, r21
     588:	09 f3       	breq	.-62     	; 0x54c <find_key_val+0x18>
     58a:	02 c0       	rjmp	.+4      	; 0x590 <find_key_val+0x5c>
                }else{
                        kp=key;
                }
                str++;
        }
        if (found==1 && *str!='&'){
     58c:	51 30       	cpi	r21, 0x01	; 1
     58e:	99 f4       	brne	.+38     	; 0x5b6 <find_key_val+0x82>
     590:	96 32       	cpi	r25, 0x26	; 38
     592:	19 f4       	brne	.+6      	; 0x59a <find_key_val+0x66>
     594:	10 c0       	rjmp	.+32     	; 0x5b6 <find_key_val+0x82>
                 while(*str  &&  *str!=' ' && *str!='\n' && *str!='&'  && maxlen-1){
                        *strbuf=*str;
     596:	89 93       	st	Y+, r24
                        i++;
                        str++;
     598:	11 96       	adiw	r26, 0x01	; 1
                        kp=key;
                }
                str++;
        }
        if (found==1 && *str!='&'){
                 while(*str  &&  *str!=' ' && *str!='\n' && *str!='&'  && maxlen-1){
     59a:	8c 91       	ld	r24, X
     59c:	88 23       	and	r24, r24
     59e:	41 f0       	breq	.+16     	; 0x5b0 <find_key_val+0x7c>
     5a0:	80 32       	cpi	r24, 0x20	; 32
     5a2:	31 f0       	breq	.+12     	; 0x5b0 <find_key_val+0x7c>
     5a4:	8a 30       	cpi	r24, 0x0A	; 10
     5a6:	21 f0       	breq	.+8      	; 0x5b0 <find_key_val+0x7c>
     5a8:	86 32       	cpi	r24, 0x26	; 38
     5aa:	11 f0       	breq	.+4      	; 0x5b0 <find_key_val+0x7c>
     5ac:	41 30       	cpi	r20, 0x01	; 1
     5ae:	99 f7       	brne	.-26     	; 0x596 <find_key_val+0x62>
                        *strbuf=*str;
                        i++;
                        str++;
                        strbuf++;
						}
                *strbuf='\0';
     5b0:	18 82       	st	Y, r1
     5b2:	81 e0       	ldi	r24, 0x01	; 1
     5b4:	01 c0       	rjmp	.+2      	; 0x5b8 <find_key_val+0x84>
				return(1);    // ЕСЛИ ПОЛЕ ЗАПОЛНЕНО ВОЗВРАЩАЕМ 1
     5b6:	80 e0       	ldi	r24, 0x00	; 0
        }
         return(i);
}
     5b8:	df 91       	pop	r29
     5ba:	cf 91       	pop	r28
     5bc:	08 95       	ret

000005be <verify_password>:
	return result;
}
// проверка пароля
// возврашаем 1 если пароль сошелся если нет 0
uint8_t verify_password(char *str)
{
     5be:	fc 01       	movw	r30, r24
         
          if(*str==0){
     5c0:	80 81       	ld	r24, Z
     5c2:	88 23       	and	r24, r24
     5c4:	11 f4       	brne	.+4      	; 0x5ca <verify_password+0xc>
     5c6:	82 e0       	ldi	r24, 0x02	; 2
     5c8:	08 95       	ret
		return(2);
}  
         if (strncmp("admin",str,5)==0){
     5ca:	80 e6       	ldi	r24, 0x60	; 96
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	bf 01       	movw	r22, r30
     5d0:	45 e0       	ldi	r20, 0x05	; 5
     5d2:	50 e0       	ldi	r21, 0x00	; 0
     5d4:	81 da       	rcall	.-2814   	; 0xfffffad8 <__eeprom_end+0xff7efab6>
     5d6:	9c 01       	movw	r18, r24
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	23 2b       	or	r18, r19
     5dc:	09 f4       	brne	.+2      	; 0x5e0 <verify_password+0x22>
     5de:	81 e0       	ldi	r24, 0x01	; 1
                return(1);
        }
        return(0);
} 
     5e0:	08 95       	ret

000005e2 <mk_net_str>:
	 plen=fill_tcp_data_p(buf,plen,PSTR("<br></i></body>"));
	 return(plen);
}
// преобразуем цифровое значение поля в acsi код
void mk_net_str(char *resultstr,uint8_t *bytestr,uint8_t len,char separator,uint8_t base)
{
     5e2:	bf 92       	push	r11
     5e4:	cf 92       	push	r12
     5e6:	df 92       	push	r13
     5e8:	ef 92       	push	r14
     5ea:	ff 92       	push	r15
     5ec:	0f 93       	push	r16
     5ee:	1f 93       	push	r17
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	7c 01       	movw	r14, r24
     5f6:	b4 2e       	mov	r11, r20
     5f8:	c2 2e       	mov	r12, r18
     5fa:	d0 2e       	mov	r13, r16
     5fc:	eb 01       	movw	r28, r22
     5fe:	00 e0       	ldi	r16, 0x00	; 0
     600:	10 e0       	ldi	r17, 0x00	; 0
     602:	16 c0       	rjmp	.+44     	; 0x630 <mk_net_str+0x4e>
        uint8_t i=0;
        uint8_t j=0;
        while(i<len){
                itoa((int)bytestr[i],&resultstr[j],base);
     604:	b7 01       	movw	r22, r14
     606:	61 0f       	add	r22, r17
     608:	71 1d       	adc	r23, r1
     60a:	88 81       	ld	r24, Y
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	4d 2d       	mov	r20, r13
     610:	50 e0       	ldi	r21, 0x00	; 0
     612:	8a da       	rcall	.-2796   	; 0xfffffb28 <__eeprom_end+0xff7efb06>
     614:	01 c0       	rjmp	.+2      	; 0x618 <mk_net_str+0x36>
                // search end of str:
                while(resultstr[j]){j++;}
     616:	19 2f       	mov	r17, r25
     618:	f7 01       	movw	r30, r14
     61a:	e1 0f       	add	r30, r17
     61c:	f1 1d       	adc	r31, r1
     61e:	80 81       	ld	r24, Z
     620:	91 2f       	mov	r25, r17
     622:	9f 5f       	subi	r25, 0xFF	; 255
     624:	88 23       	and	r24, r24
     626:	b9 f7       	brne	.-18     	; 0x616 <mk_net_str+0x34>
                resultstr[j]=separator;
     628:	c0 82       	st	Z, r12
                j++;
     62a:	19 2f       	mov	r17, r25
                i++;
     62c:	0f 5f       	subi	r16, 0xFF	; 255
     62e:	21 96       	adiw	r28, 0x01	; 1
// преобразуем цифровое значение поля в acsi код
void mk_net_str(char *resultstr,uint8_t *bytestr,uint8_t len,char separator,uint8_t base)
{
        uint8_t i=0;
        uint8_t j=0;
        while(i<len){
     630:	0b 15       	cp	r16, r11
     632:	40 f3       	brcs	.-48     	; 0x604 <mk_net_str+0x22>
                resultstr[j]=separator;
                j++;
                i++;
        }
        j--;
        resultstr[j]='\0';
     634:	11 50       	subi	r17, 0x01	; 1
     636:	e1 0e       	add	r14, r17
     638:	f1 1c       	adc	r15, r1
     63a:	f7 01       	movw	r30, r14
     63c:	10 82       	st	Z, r1
} 	
     63e:	df 91       	pop	r29
     640:	cf 91       	pop	r28
     642:	1f 91       	pop	r17
     644:	0f 91       	pop	r16
     646:	ff 90       	pop	r15
     648:	ef 90       	pop	r14
     64a:	df 90       	pop	r13
     64c:	cf 90       	pop	r12
     64e:	bf 90       	pop	r11
     650:	08 95       	ret

00000652 <print_webpage_config>:
	
        return(plen);
}
 // страница конфигурации 
uint16_t print_webpage_config(uint8_t *buf)
{
     652:	af 92       	push	r10
     654:	bf 92       	push	r11
     656:	cf 92       	push	r12
     658:	df 92       	push	r13
     65a:	ef 92       	push	r14
     65c:	ff 92       	push	r15
     65e:	0f 93       	push	r16
     660:	1f 93       	push	r17
     662:	6c 01       	movw	r12, r24
     uint16_t plen=0;
	 plen=fill_tcp_data_p(buf,plen,PSTR("<br><br><br><br><br><form action=/form method=get><div ALIGN=CENTER> Новый IP &nbsp <input type=text name=ip value="));
     664:	60 e0       	ldi	r22, 0x00	; 0
     666:	70 e0       	ldi	r23, 0x00	; 0
     668:	4e eb       	ldi	r20, 0xBE	; 190
     66a:	52 e0       	ldi	r21, 0x02	; 2
     66c:	d9 d5       	rcall	.+2994   	; 0x1220 <fill_tcp_data_p>
     66e:	5c 01       	movw	r10, r24
	 mk_net_str(ip_screen,myip_new,4,'.',10);
     670:	82 e7       	ldi	r24, 0x72	; 114
     672:	e8 2e       	mov	r14, r24
     674:	83 e0       	ldi	r24, 0x03	; 3
     676:	f8 2e       	mov	r15, r24
     678:	c7 01       	movw	r24, r14
     67a:	6c ea       	ldi	r22, 0xAC	; 172
     67c:	73 e0       	ldi	r23, 0x03	; 3
     67e:	44 e0       	ldi	r20, 0x04	; 4
     680:	50 e0       	ldi	r21, 0x00	; 0
     682:	2e e2       	ldi	r18, 0x2E	; 46
     684:	30 e0       	ldi	r19, 0x00	; 0
     686:	0a e0       	ldi	r16, 0x0A	; 10
     688:	10 e0       	ldi	r17, 0x00	; 0
     68a:	ab df       	rcall	.-170    	; 0x5e2 <mk_net_str>
     plen=fill_tcp_data(buf,plen,ip_screen);
     68c:	c6 01       	movw	r24, r12
     68e:	b5 01       	movw	r22, r10
     690:	a7 01       	movw	r20, r14
     692:	d9 d5       	rcall	.+2994   	; 0x1246 <fill_tcp_data>
     694:	bc 01       	movw	r22, r24
	 plen=fill_tcp_data_p(buf,plen,PSTR("><br><br>IP Шлюза  &nbsp<input type=text name=gw value="));
     696:	c6 01       	movw	r24, r12
     698:	46 e8       	ldi	r20, 0x86	; 134
     69a:	52 e0       	ldi	r21, 0x02	; 2
     69c:	c1 d5       	rcall	.+2946   	; 0x1220 <fill_tcp_data_p>
     69e:	5c 01       	movw	r10, r24
	 mk_net_str(ip_screen,searash_gw,4,'.',10);
     6a0:	c7 01       	movw	r24, r14
     6a2:	61 e9       	ldi	r22, 0x91	; 145
     6a4:	70 e0       	ldi	r23, 0x00	; 0
     6a6:	44 e0       	ldi	r20, 0x04	; 4
     6a8:	50 e0       	ldi	r21, 0x00	; 0
     6aa:	2e e2       	ldi	r18, 0x2E	; 46
     6ac:	30 e0       	ldi	r19, 0x00	; 0
     6ae:	99 df       	rcall	.-206    	; 0x5e2 <mk_net_str>
     plen=fill_tcp_data(buf,plen,ip_screen);
     6b0:	c6 01       	movw	r24, r12
     6b2:	b5 01       	movw	r22, r10
     6b4:	a7 01       	movw	r20, r14
     6b6:	c7 d5       	rcall	.+2958   	; 0x1246 <fill_tcp_data>
     6b8:	bc 01       	movw	r22, r24
	 plen=fill_tcp_data_p(buf,plen,PSTR("><br><br> Маска подсети &nbsp<input type=text name=ms value="));
     6ba:	c6 01       	movw	r24, r12
     6bc:	49 e4       	ldi	r20, 0x49	; 73
     6be:	52 e0       	ldi	r21, 0x02	; 2
     6c0:	af d5       	rcall	.+2910   	; 0x1220 <fill_tcp_data_p>
     6c2:	5c 01       	movw	r10, r24
	 mk_net_str(ip_screen,searash_subnet,4,'.',10);
     6c4:	c7 01       	movw	r24, r14
     6c6:	65 e9       	ldi	r22, 0x95	; 149
     6c8:	70 e0       	ldi	r23, 0x00	; 0
     6ca:	44 e0       	ldi	r20, 0x04	; 4
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	2e e2       	ldi	r18, 0x2E	; 46
     6d0:	30 e0       	ldi	r19, 0x00	; 0
     6d2:	87 df       	rcall	.-242    	; 0x5e2 <mk_net_str>
	 plen=fill_tcp_data(buf,plen,ip_screen);
     6d4:	c6 01       	movw	r24, r12
     6d6:	b5 01       	movw	r22, r10
     6d8:	a7 01       	movw	r20, r14
     6da:	b5 d5       	rcall	.+2922   	; 0x1246 <fill_tcp_data>
     6dc:	bc 01       	movw	r22, r24
	 plen=fill_tcp_data_p(buf,plen,PSTR("><br><br> Mac Шлюза &nbsp<input type=text  value="));
     6de:	c6 01       	movw	r24, r12
     6e0:	47 e1       	ldi	r20, 0x17	; 23
     6e2:	52 e0       	ldi	r21, 0x02	; 2
     6e4:	9d d5       	rcall	.+2874   	; 0x1220 <fill_tcp_data_p>
     6e6:	5c 01       	movw	r10, r24
	 mk_net_str(ip_screen,searash_mac_,6,':',16);
     6e8:	c7 01       	movw	r24, r14
     6ea:	69 e9       	ldi	r22, 0x99	; 153
     6ec:	70 e0       	ldi	r23, 0x00	; 0
     6ee:	46 e0       	ldi	r20, 0x06	; 6
     6f0:	50 e0       	ldi	r21, 0x00	; 0
     6f2:	2a e3       	ldi	r18, 0x3A	; 58
     6f4:	30 e0       	ldi	r19, 0x00	; 0
     6f6:	00 e1       	ldi	r16, 0x10	; 16
     6f8:	10 e0       	ldi	r17, 0x00	; 0
     6fa:	73 df       	rcall	.-282    	; 0x5e2 <mk_net_str>
	 plen=fill_tcp_data(buf,plen,ip_screen);
     6fc:	c6 01       	movw	r24, r12
     6fe:	b5 01       	movw	r22, r10
     700:	a7 01       	movw	r20, r14
     702:	a1 d5       	rcall	.+2882   	; 0x1246 <fill_tcp_data>
     704:	bc 01       	movw	r22, r24
	 plen=fill_tcp_data_p(buf,plen,PSTR("><br><br>Пароль &nbsp<input type=password name=pw>\n &nbsp &nbsp<input type=submit value=отправить ></form>\n"));
     706:	c6 01       	movw	r24, r12
     708:	4b ea       	ldi	r20, 0xAB	; 171
     70a:	51 e0       	ldi	r21, 0x01	; 1
     70c:	89 d5       	rcall	.+2834   	; 0x1220 <fill_tcp_data_p>
     70e:	bc 01       	movw	r22, r24
	 plen=fill_tcp_data_p(buf,plen,PSTR("<br></i></body>"));
     710:	c6 01       	movw	r24, r12
     712:	4b e9       	ldi	r20, 0x9B	; 155
     714:	51 e0       	ldi	r21, 0x01	; 1
     716:	84 d5       	rcall	.+2824   	; 0x1220 <fill_tcp_data_p>
	 return(plen);
}
     718:	1f 91       	pop	r17
     71a:	0f 91       	pop	r16
     71c:	ff 90       	pop	r15
     71e:	ef 90       	pop	r14
     720:	df 90       	pop	r13
     722:	cf 90       	pop	r12
     724:	bf 90       	pop	r11
     726:	af 90       	pop	r10
     728:	08 95       	ret

0000072a <parse_ip>:
        }
         return(i);
}
// преобразуем принятый ip в цифры и копируем в буфер
uint8_t parse_ip(uint8_t *bytestr,char *str)
{
     72a:	ef 92       	push	r14
     72c:	ff 92       	push	r15
     72e:	1f 93       	push	r17
     730:	cf 93       	push	r28
     732:	df 93       	push	r29
     734:	7c 01       	movw	r14, r24
     736:	eb 01       	movw	r28, r22
     738:	80 e0       	ldi	r24, 0x00	; 0
     73a:	90 e0       	ldi	r25, 0x00	; 0
        char *sptr;
        uint8_t i=0;
        sptr=NULL;
        while(i<4){
                bytestr[i]=0;
     73c:	f7 01       	movw	r30, r14
     73e:	e8 0f       	add	r30, r24
     740:	f9 1f       	adc	r31, r25
     742:	10 82       	st	Z, r1
     744:	01 96       	adiw	r24, 0x01	; 1
uint8_t parse_ip(uint8_t *bytestr,char *str)
{
        char *sptr;
        uint8_t i=0;
        sptr=NULL;
        while(i<4){
     746:	84 30       	cpi	r24, 0x04	; 4
     748:	91 05       	cpc	r25, r1
     74a:	c1 f7       	brne	.-16     	; 0x73c <parse_ip+0x12>
     74c:	20 e0       	ldi	r18, 0x00	; 0
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	10 e0       	ldi	r17, 0x00	; 0
     752:	16 c0       	rjmp	.+44     	; 0x780 <parse_ip+0x56>
                bytestr[i]=0;
                i++;
        }
        i=0;
        while(*str && i<4){
                if (sptr==NULL && isdigit(*str)){
     754:	21 15       	cp	r18, r1
     756:	31 05       	cpc	r19, r1
     758:	31 f4       	brne	.+12     	; 0x766 <parse_ip+0x3c>
     75a:	84 2f       	mov	r24, r20
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	c0 97       	sbiw	r24, 0x30	; 48
     760:	0a 97       	sbiw	r24, 0x0a	; 10
     762:	08 f4       	brcc	.+2      	; 0x766 <parse_ip+0x3c>
     764:	9e 01       	movw	r18, r28
                        sptr=str;
                }
                if (*str == '.'){
     766:	4e 32       	cpi	r20, 0x2E	; 46
     768:	51 f4       	brne	.+20     	; 0x77e <parse_ip+0x54>
                        *str ='\0';
     76a:	18 82       	st	Y, r1
                        bytestr[i]=(atoi(sptr)&0xff);
     76c:	c9 01       	movw	r24, r18
     76e:	97 d9       	rcall	.-3282   	; 0xfffffa9e <__eeprom_end+0xff7efa7c>
     770:	f7 01       	movw	r30, r14
     772:	e1 0f       	add	r30, r17
     774:	f1 1d       	adc	r31, r1
     776:	80 83       	st	Z, r24
                        i++;
     778:	1f 5f       	subi	r17, 0xFF	; 255
     77a:	20 e0       	ldi	r18, 0x00	; 0
     77c:	30 e0       	ldi	r19, 0x00	; 0
                        sptr=NULL;
                }
                str++;
     77e:	21 96       	adiw	r28, 0x01	; 1
        while(i<4){
                bytestr[i]=0;
                i++;
        }
        i=0;
        while(*str && i<4){
     780:	48 81       	ld	r20, Y
     782:	44 23       	and	r20, r20
     784:	11 f0       	breq	.+4      	; 0x78a <parse_ip+0x60>
     786:	14 30       	cpi	r17, 0x04	; 4
     788:	28 f3       	brcs	.-54     	; 0x754 <parse_ip+0x2a>
                        i++;
                        sptr=NULL;
                }
                str++;
        }
        *str ='\0';
     78a:	18 82       	st	Y, r1
        if (i==3){
     78c:	13 30       	cpi	r17, 0x03	; 3
     78e:	11 f0       	breq	.+4      	; 0x794 <parse_ip+0x6a>
     790:	8a e0       	ldi	r24, 0x0A	; 10
     792:	05 c0       	rjmp	.+10     	; 0x79e <parse_ip+0x74>
                bytestr[i]=(atoi(sptr)&0xff);
     794:	c9 01       	movw	r24, r18
     796:	83 d9       	rcall	.-3322   	; 0xfffffa9e <__eeprom_end+0xff7efa7c>
     798:	f7 01       	movw	r30, r14
     79a:	83 83       	std	Z+3, r24	; 0x03
     79c:	80 e0       	ldi	r24, 0x00	; 0
                return(0);
        }
return(10);		
       }
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	1f 91       	pop	r17
     7a4:	ff 90       	pop	r15
     7a6:	ef 90       	pop	r14
     7a8:	08 95       	ret

000007aa <analyse_get_url>:
// анализируем принятый URL	   на предмет наличия ключевых слов 
// возвращаем номер принятого ключа
uint8_t analyse_get_url(char *str)
{      
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	ec 01       	movw	r28, r24
        pw_status=0;
     7b0:	10 92 ab 03 	sts	0x03AB, r1
		 if (str[0] == '/' && str[1] == ' '){
     7b4:	88 81       	ld	r24, Y
     7b6:	8f 32       	cpi	r24, 0x2F	; 47
     7b8:	21 f4       	brne	.+8      	; 0x7c2 <analyse_get_url+0x18>
     7ba:	89 81       	ldd	r24, Y+1	; 0x01
     7bc:	80 32       	cpi	r24, 0x20	; 32
     7be:	09 f4       	brne	.+2      	; 0x7c2 <analyse_get_url+0x18>
     7c0:	4b c0       	rjmp	.+150    	; 0x858 <analyse_get_url+0xae>
                // если начальная страница
                return(2);
        }
        if (strncmp("/config",str,7)==0){    // если это конфиг
     7c2:	86 e6       	ldi	r24, 0x66	; 102
     7c4:	90 e0       	ldi	r25, 0x00	; 0
     7c6:	be 01       	movw	r22, r28
     7c8:	47 e0       	ldi	r20, 0x07	; 7
     7ca:	50 e0       	ldi	r21, 0x00	; 0
     7cc:	85 d9       	rcall	.-3318   	; 0xfffffad8 <__eeprom_end+0xff7efab6>
     7ce:	00 97       	sbiw	r24, 0x00	; 0
     7d0:	11 f4       	brne	.+4      	; 0x7d6 <analyse_get_url+0x2c>
     7d2:	83 e0       	ldi	r24, 0x03	; 3
     7d4:	42 c0       	rjmp	.+132    	; 0x85a <analyse_get_url+0xb0>
                return(3); 
		}		
        if (strncmp("/form?",str,6)==0){         // это form
     7d6:	8e e6       	ldi	r24, 0x6E	; 110
     7d8:	90 e0       	ldi	r25, 0x00	; 0
     7da:	be 01       	movw	r22, r28
     7dc:	46 e0       	ldi	r20, 0x06	; 6
     7de:	50 e0       	ldi	r21, 0x00	; 0
     7e0:	7b d9       	rcall	.-3338   	; 0xfffffad8 <__eeprom_end+0xff7efab6>
     7e2:	00 97       	sbiw	r24, 0x00	; 0
     7e4:	c1 f5       	brne	.+112    	; 0x856 <analyse_get_url+0xac>
		if(find_key_val(str,gStrbuf,STR_BUFFER_SIZE,"pw")){
     7e6:	ce 01       	movw	r24, r28
     7e8:	6e ec       	ldi	r22, 0xCE	; 206
     7ea:	72 e0       	ldi	r23, 0x02	; 2
     7ec:	42 e3       	ldi	r20, 0x32	; 50
     7ee:	25 e7       	ldi	r18, 0x75	; 117
     7f0:	30 e0       	ldi	r19, 0x00	; 0
     7f2:	a0 de       	rcall	.-704    	; 0x534 <find_key_val>
     7f4:	88 23       	and	r24, r24
     7f6:	79 f1       	breq	.+94     	; 0x856 <analyse_get_url+0xac>
		  pw_status=verify_password(gStrbuf); 
     7f8:	8e ec       	ldi	r24, 0xCE	; 206
     7fa:	92 e0       	ldi	r25, 0x02	; 2
     7fc:	e0 de       	rcall	.-576    	; 0x5be <verify_password>
     7fe:	80 93 ab 03 	sts	0x03AB, r24
            if(find_key_val(str,gStrbuf,STR_BUFFER_SIZE,"ip"));
     802:	ce 01       	movw	r24, r28
     804:	6e ec       	ldi	r22, 0xCE	; 206
     806:	72 e0       	ldi	r23, 0x02	; 2
     808:	42 e3       	ldi	r20, 0x32	; 50
     80a:	28 e7       	ldi	r18, 0x78	; 120
     80c:	30 e0       	ldi	r19, 0x00	; 0
     80e:	92 de       	rcall	.-732    	; 0x534 <find_key_val>
                                       parse_ip(myip_new,gStrbuf);
     810:	8c ea       	ldi	r24, 0xAC	; 172
     812:	93 e0       	ldi	r25, 0x03	; 3
     814:	6e ec       	ldi	r22, 0xCE	; 206
     816:	72 e0       	ldi	r23, 0x02	; 2
     818:	88 df       	rcall	.-240    	; 0x72a <parse_ip>
									  // return(1);
			if(find_key_val(str,gStrbuf,STR_BUFFER_SIZE,"ms")){ // если это поле маски подсети
     81a:	ce 01       	movw	r24, r28
     81c:	6e ec       	ldi	r22, 0xCE	; 206
     81e:	72 e0       	ldi	r23, 0x02	; 2
     820:	42 e3       	ldi	r20, 0x32	; 50
     822:	2b e7       	ldi	r18, 0x7B	; 123
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	86 de       	rcall	.-756    	; 0x534 <find_key_val>
     828:	88 23       	and	r24, r24
     82a:	29 f0       	breq	.+10     	; 0x836 <analyse_get_url+0x8c>
		                              parse_ip(searash_subnet,gStrbuf); // копируем в буфер
     82c:	85 e9       	ldi	r24, 0x95	; 149
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	6e ec       	ldi	r22, 0xCE	; 206
     832:	72 e0       	ldi	r23, 0x02	; 2
     834:	7a df       	rcall	.-268    	; 0x72a <parse_ip>
									   //return(5);    
									   } 						    // return(1);    
		    if(find_key_val(str,gStrbuf,STR_BUFFER_SIZE,"gw")){        // если это поле шлюза
     836:	ce 01       	movw	r24, r28
     838:	6e ec       	ldi	r22, 0xCE	; 206
     83a:	72 e0       	ldi	r23, 0x02	; 2
     83c:	42 e3       	ldi	r20, 0x32	; 50
     83e:	2e e7       	ldi	r18, 0x7E	; 126
     840:	30 e0       	ldi	r19, 0x00	; 0
     842:	78 de       	rcall	.-784    	; 0x534 <find_key_val>
     844:	88 23       	and	r24, r24
     846:	49 f0       	breq	.+18     	; 0x85a <analyse_get_url+0xb0>
                                      parse_ip(searash_gw,gStrbuf);     // копируем в буфер
     848:	81 e9       	ldi	r24, 0x91	; 145
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	6e ec       	ldi	r22, 0xCE	; 206
     84e:	72 e0       	ldi	r23, 0x02	; 2
     850:	6c df       	rcall	.-296    	; 0x72a <parse_ip>
     852:	84 e0       	ldi	r24, 0x04	; 4
     854:	02 c0       	rjmp	.+4      	; 0x85a <analyse_get_url+0xb0>
     856:	01 c0       	rjmp	.+2      	; 0x85a <analyse_get_url+0xb0>
									   return(4);    
									   } 									
		    return(0);  		// 	если другое	   
									   }
									   }
									   }
     858:	82 e0       	ldi	r24, 0x02	; 2
     85a:	df 91       	pop	r29
     85c:	cf 91       	pop	r28
     85e:	08 95       	ret

00000860 <temperature>:
// прерывание по таймеру	
 ISR(TIMER1_OVF_vect)
 {
 time++; //  увеличиваем счетчик
 } 
uint8_t temperature(int *temp) {
     860:	1f 93       	push	r17
  
	ow_reset();							// сброс 1-wire
     862:	53 d6       	rcall	.+3238   	; 0x150a <ow_reset>
	ow_write_byte(OW_SKIP_ROM_CMD);		// команда "пропустить адрес"
     864:	8c ec       	ldi	r24, 0xCC	; 204
     866:	9c d6       	rcall	.+3384   	; 0x15a0 <ow_write_byte>
	ow_write_byte(CMD_START_CONV);		// команда "начать измерение"
     868:	84 e4       	ldi	r24, 0x44	; 68
     86a:	9a d6       	rcall	.+3380   	; 0x15a0 <ow_write_byte>
     86c:	88 ee       	ldi	r24, 0xE8	; 232
     86e:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     870:	2c e2       	ldi	r18, 0x2C	; 44
     872:	31 e0       	ldi	r19, 0x01	; 1
     874:	f9 01       	movw	r30, r18
     876:	31 97       	sbiw	r30, 0x01	; 1
     878:	f1 f7       	brne	.-4      	; 0x876 <temperature+0x16>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     87a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     87c:	d9 f7       	brne	.-10     	; 0x874 <temperature+0x14>
    _delay_ms(100);
	ow_reset();                        // сброс 1-wire
     87e:	45 d6       	rcall	.+3210   	; 0x150a <ow_reset>
	//каков бы ни был результат опроса датчика, делаем повторный запуск измерения
	ow_write_byte(OW_SKIP_ROM_CMD);		// команда "пропустить адрес"
     880:	8c ec       	ldi	r24, 0xCC	; 204
     882:	8e d6       	rcall	.+3356   	; 0x15a0 <ow_write_byte>
	 ow_write_byte(CMD_RD_SCRPAD);		// команда "считать регистры датчика"
     884:	8e eb       	ldi	r24, 0xBE	; 190
     886:	8c d6       	rcall	.+3352   	; 0x15a0 <ow_write_byte>
    //чтение данных из датчика
	for( i=0;i<9;i++){                 // читаем до тех пор пока не получим все 9 байтов
     888:	10 92 7a 03 	sts	0x037A, r1
     88c:	17 c0       	rjmp	.+46     	; 0x8bc <temperature+0x5c>
		buf_ware[i]=ow_read_byte();	// читаем байт в буфер
     88e:	10 91 7a 03 	lds	r17, 0x037A
     892:	96 d6       	rcall	.+3372   	; 0x15c0 <ow_read_byte>
     894:	e1 2f       	mov	r30, r17
     896:	f0 e0       	ldi	r31, 0x00	; 0
     898:	eb 59       	subi	r30, 0x9B	; 155
     89a:	fc 4f       	sbci	r31, 0xFC	; 252
     89c:	80 83       	st	Z, r24
	   tt = (*tmp>>1);			  
     89e:	e0 91 86 00 	lds	r30, 0x0086
     8a2:	f0 91 87 00 	lds	r31, 0x0087
     8a6:	80 81       	ld	r24, Z
     8a8:	91 81       	ldd	r25, Z+1	; 0x01
     8aa:	96 95       	lsr	r25
     8ac:	87 95       	ror	r24
     8ae:	80 93 7b 03 	sts	0x037B, r24
	ow_reset();                        // сброс 1-wire
	//каков бы ни был результат опроса датчика, делаем повторный запуск измерения
	ow_write_byte(OW_SKIP_ROM_CMD);		// команда "пропустить адрес"
	 ow_write_byte(CMD_RD_SCRPAD);		// команда "считать регистры датчика"
    //чтение данных из датчика
	for( i=0;i<9;i++){                 // читаем до тех пор пока не получим все 9 байтов
     8b2:	80 91 7a 03 	lds	r24, 0x037A
     8b6:	8f 5f       	subi	r24, 0xFF	; 255
     8b8:	80 93 7a 03 	sts	0x037A, r24
     8bc:	80 91 7a 03 	lds	r24, 0x037A
     8c0:	89 30       	cpi	r24, 0x09	; 9
     8c2:	28 f3       	brcs	.-54     	; 0x88e <temperature+0x2e>
		buf_ware[i]=ow_read_byte();	// читаем байт в буфер
	   tt = (*tmp>>1);			  
		//t = tt ;	                    
		//*temp = tt;					    
	} 
    tt = (*tmp>>4);                        // выкидываем доли температуры
     8c4:	e0 91 86 00 	lds	r30, 0x0086
     8c8:	f0 91 87 00 	lds	r31, 0x0087
     8cc:	80 81       	ld	r24, Z
     8ce:	91 81       	ldd	r25, Z+1	; 0x01
     8d0:	24 e0       	ldi	r18, 0x04	; 4
     8d2:	96 95       	lsr	r25
     8d4:	87 95       	ror	r24
     8d6:	2a 95       	dec	r18
     8d8:	e1 f7       	brne	.-8      	; 0x8d2 <temperature+0x72>
     8da:	80 93 7b 03 	sts	0x037B, r24
	t=tt & 0x00ff;                          // выкидываеи ст байт 
     8de:	28 2f       	mov	r18, r24
     8e0:	30 e0       	ldi	r19, 0x00	; 0
     8e2:	30 93 1a 03 	sts	0x031A, r19
     8e6:	20 93 19 03 	sts	0x0319, r18
	if(tt>127){                             // если температуоа отрицательная
     8ea:	87 ff       	sbrs	r24, 7
     8ec:	06 c0       	rjmp	.+12     	; 0x8fa <temperature+0x9a>
	t=tt-256;                             
     8ee:	20 50       	subi	r18, 0x00	; 0
     8f0:	31 40       	sbci	r19, 0x01	; 1
     8f2:	30 93 1a 03 	sts	0x031A, r19
     8f6:	20 93 19 03 	sts	0x0319, r18
	}else{
	}                      
	ow_reset();	
     8fa:	07 d6       	rcall	.+3086   	; 0x150a <ow_reset>
	
					// сброс 1-wire
	// возвращаем результат опроса датчика
	return result;
}
     8fc:	80 91 7d 03 	lds	r24, 0x037D
     900:	1f 91       	pop	r17
     902:	08 95       	ret

00000904 <print_webpage>:
									   }
									   }
									   
//Сдесь выводим нашу страничку
uint16_t print_webpage(uint8_t *buf)
{
     904:	0f 93       	push	r16
     906:	1f 93       	push	r17
     908:	cf 93       	push	r28
     90a:	df 93       	push	r29
     90c:	ec 01       	movw	r28, r24
     uint16_t plen=0;
	 result=ow_reset();
     90e:	fd d5       	rcall	.+3066   	; 0x150a <ow_reset>
     910:	80 93 7d 03 	sts	0x037D, r24
     plen=fill_tcp_data_p(buf,plen,PSTR("<head><META HTTP-EQUIV=REFRESH CONTENT=3><title>Термосервер</title></head><body><div ALIGN=CENTER><i><pre><h1>ТЕРМОСЕРВЕР</pre></h1><br>"));
     914:	ce 01       	movw	r24, r28
     916:	60 e0       	ldi	r22, 0x00	; 0
     918:	70 e0       	ldi	r23, 0x00	; 0
     91a:	40 e3       	ldi	r20, 0x30	; 48
     91c:	54 e0       	ldi	r21, 0x04	; 4
     91e:	80 d4       	rcall	.+2304   	; 0x1220 <fill_tcp_data_p>
     920:	8c 01       	movw	r16, r24
	 if (result!=1){
     922:	80 91 7d 03 	lds	r24, 0x037D
     926:	81 30       	cpi	r24, 0x01	; 1
     928:	31 f0       	breq	.+12     	; 0x936 <print_webpage+0x32>
     plen=fill_tcp_data_p(buf,plen,PSTR(" Датчик не найден <br><br><br>  </i></body>"));
     92a:	ce 01       	movw	r24, r28
     92c:	b8 01       	movw	r22, r16
     92e:	44 e0       	ldi	r20, 0x04	; 4
     930:	54 e0       	ldi	r21, 0x04	; 4
     932:	76 d4       	rcall	.+2284   	; 0x1220 <fill_tcp_data_p>
     934:	1a c0       	rjmp	.+52     	; 0x96a <print_webpage+0x66>
     }else{
	 temperature(&t);
     936:	89 e1       	ldi	r24, 0x19	; 25
     938:	93 e0       	ldi	r25, 0x03	; 3
     93a:	92 df       	rcall	.-220    	; 0x860 <temperature>
	 termus=t; 
     93c:	80 91 19 03 	lds	r24, 0x0319
     940:	90 91 1a 03 	lds	r25, 0x031A
     944:	90 93 63 03 	sts	0x0363, r25
     948:	80 93 62 03 	sts	0x0362, r24
     itoa(termus,rr,10);
     94c:	60 eb       	ldi	r22, 0xB0	; 176
     94e:	73 e0       	ldi	r23, 0x03	; 3
     950:	4a e0       	ldi	r20, 0x0A	; 10
     952:	50 e0       	ldi	r21, 0x00	; 0
     954:	e9 d8       	rcall	.-3630   	; 0xfffffb28 <__eeprom_end+0xff7efb06>
	 plen=fill_tcp_data_p(buf,plen,PSTR("<div ALIGN=CENTER><br>Температура : "));
     956:	ce 01       	movw	r24, r28
     958:	b8 01       	movw	r22, r16
     95a:	4f ed       	ldi	r20, 0xDF	; 223
     95c:	53 e0       	ldi	r21, 0x03	; 3
     95e:	60 d4       	rcall	.+2240   	; 0x1220 <fill_tcp_data_p>
     960:	bc 01       	movw	r22, r24
	 plen=fill_tcp_data(buf,plen,rr);
     962:	ce 01       	movw	r24, r28
     964:	40 eb       	ldi	r20, 0xB0	; 176
     966:	53 e0       	ldi	r21, 0x03	; 3
     968:	6e d4       	rcall	.+2268   	; 0x1246 <fill_tcp_data>
     96a:	bc 01       	movw	r22, r24
	 }
	 plen=fill_tcp_data_p(buf,plen,PSTR("<br><br><br><br><br><form action=/config method=get><div ALIGN=CENTER>Переход на страницу конфигурации &nbsp &nbsp<input type=submit value=Перейти ></form>\n"));
     96c:	ce 01       	movw	r24, r28
     96e:	42 e4       	ldi	r20, 0x42	; 66
     970:	53 e0       	ldi	r21, 0x03	; 3
     972:	56 d4       	rcall	.+2220   	; 0x1220 <fill_tcp_data_p>
     974:	bc 01       	movw	r22, r24
	// if (flag==1){ 
    // plen=fill_tcp_data_p(buf,plen,PSTR("узел находится в нашей подсети<br></i></body>"));
	//// }else{
	// plen=fill_tcp_data_p(buf,plen,PSTR("узел находится не в нашей  подсети<br></i></body>"));
	// }
	  plen=fill_tcp_data_p(buf,plen,PSTR("<br></i></body>"));
     976:	ce 01       	movw	r24, r28
     978:	42 e3       	ldi	r20, 0x32	; 50
     97a:	53 e0       	ldi	r21, 0x03	; 3
     97c:	51 d4       	rcall	.+2210   	; 0x1220 <fill_tcp_data_p>
	
        return(plen);
}
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	1f 91       	pop	r17
     984:	0f 91       	pop	r16
     986:	08 95       	ret

00000988 <main>:
        }
        j--;
        resultstr[j]='\0';
} 	
//  главный цикл							
int main(void){
     988:	cf 92       	push	r12
     98a:	df 92       	push	r13
     98c:	ef 92       	push	r14
     98e:	ff 92       	push	r15
     990:	0f 93       	push	r16
     992:	1f 93       	push	r17
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
        int8_t  cmd;
        uint16_t plen;
        uint16_t dat_p;
        WDTCR = (1<<WDCE) | (1<<WDE);
     998:	88 e1       	ldi	r24, 0x18	; 24
     99a:	81 bd       	out	0x21, r24	; 33
       /* Выкл. сторожевого таймера */
        WDTCR = 0x00; 
     99c:	11 bc       	out	0x21, r1	; 33
		PORT_reset|=BV(3);		// настраиваем порт для сброса
     99e:	ab 9a       	sbi	0x15, 3	; 21
        DDR_reset|=~BV(3);
     9a0:	84 b3       	in	r24, 0x14	; 20
     9a2:	87 6f       	ori	r24, 0xF7	; 247
     9a4:	84 bb       	out	0x14, r24	; 20
		// настроим таймкр для отсылки arp
		TCCR1A&=0x00; // нормальный режим
     9a6:	8f b5       	in	r24, 0x2f	; 47
     9a8:	1f bc       	out	0x2f, r1	; 47
		TCCR1B|=0b00000101;// установим предделитель
     9aa:	8e b5       	in	r24, 0x2e	; 46
     9ac:	85 60       	ori	r24, 0x05	; 5
     9ae:	8e bd       	out	0x2e, r24	; 46
		TIMSK|=_BV(TOIE1); // РАЗРЕШИМ ПРЕРЫВАНИЯ
     9b0:	89 b7       	in	r24, 0x39	; 57
     9b2:	84 60       	ori	r24, 0x04	; 4
     9b4:	89 bf       	out	0x39, r24	; 57
		sei();// глобально
     9b6:	78 94       	sei
		 for( i=0;i<=4;i++){                 // читаем ip до тех пор пока не получим все 4 байт
     9b8:	10 92 7a 03 	sts	0x037A, r1
     9bc:	16 c0       	rjmp	.+44     	; 0x9ea <main+0x62>
		myip_new[i]= eeprom_read_byte(&(myip[i]));	// читаем байт в буфер  
     9be:	e0 91 7a 03 	lds	r30, 0x037A
     9c2:	80 91 7a 03 	lds	r24, 0x037A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     9c6:	e1 99       	sbic	0x1c, 1	; 28
     9c8:	fe cf       	rjmp	.-4      	; 0x9c6 <main+0x3e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	80 50       	subi	r24, 0x00	; 0
     9ce:	90 40       	sbci	r25, 0x00	; 0
     9d0:	9f bb       	out	0x1f, r25	; 31
     9d2:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     9d4:	e0 9a       	sbi	0x1c, 0	; 28
     9d6:	8d b3       	in	r24, 0x1d	; 29
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	e4 55       	subi	r30, 0x54	; 84
     9dc:	fc 4f       	sbci	r31, 0xFC	; 252
     9de:	80 83       	st	Z, r24
		// настроим таймкр для отсылки arp
		TCCR1A&=0x00; // нормальный режим
		TCCR1B|=0b00000101;// установим предделитель
		TIMSK|=_BV(TOIE1); // РАЗРЕШИМ ПРЕРЫВАНИЯ
		sei();// глобально
		 for( i=0;i<=4;i++){                 // читаем ip до тех пор пока не получим все 4 байт
     9e0:	80 91 7a 03 	lds	r24, 0x037A
     9e4:	8f 5f       	subi	r24, 0xFF	; 255
     9e6:	80 93 7a 03 	sts	0x037A, r24
     9ea:	80 91 7a 03 	lds	r24, 0x037A
     9ee:	85 30       	cpi	r24, 0x05	; 5
     9f0:	30 f3       	brcs	.-52     	; 0x9be <main+0x36>
		myip_new[i]= eeprom_read_byte(&(myip[i]));	// читаем байт в буфер  
		}
		 for( i=0;i<=4;i++){                // читаем маску подсети до тех пор пока не получим все 4 байт
     9f2:	10 92 7a 03 	sts	0x037A, r1
     9f6:	16 c0       	rjmp	.+44     	; 0xa24 <main+0x9c>
		searash_subnet[i]= eeprom_read_byte(&(subnet_mask[i])); // читаем байт в буфер  
     9f8:	e0 91 7a 03 	lds	r30, 0x037A
     9fc:	80 91 7a 03 	lds	r24, 0x037A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     a00:	e1 99       	sbic	0x1c, 1	; 28
     a02:	fe cf       	rjmp	.-4      	; 0xa00 <main+0x78>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	88 5f       	subi	r24, 0xF8	; 248
     a08:	9f 4f       	sbci	r25, 0xFF	; 255
     a0a:	9f bb       	out	0x1f, r25	; 31
     a0c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     a0e:	e0 9a       	sbi	0x1c, 0	; 28
     a10:	8d b3       	in	r24, 0x1d	; 29
     a12:	f0 e0       	ldi	r31, 0x00	; 0
     a14:	eb 56       	subi	r30, 0x6B	; 107
     a16:	ff 4f       	sbci	r31, 0xFF	; 255
     a18:	80 83       	st	Z, r24
		TIMSK|=_BV(TOIE1); // РАЗРЕШИМ ПРЕРЫВАНИЯ
		sei();// глобально
		 for( i=0;i<=4;i++){                 // читаем ip до тех пор пока не получим все 4 байт
		myip_new[i]= eeprom_read_byte(&(myip[i]));	// читаем байт в буфер  
		}
		 for( i=0;i<=4;i++){                // читаем маску подсети до тех пор пока не получим все 4 байт
     a1a:	80 91 7a 03 	lds	r24, 0x037A
     a1e:	8f 5f       	subi	r24, 0xFF	; 255
     a20:	80 93 7a 03 	sts	0x037A, r24
     a24:	80 91 7a 03 	lds	r24, 0x037A
     a28:	85 30       	cpi	r24, 0x05	; 5
     a2a:	30 f3       	brcs	.-52     	; 0x9f8 <main+0x70>
		searash_subnet[i]= eeprom_read_byte(&(subnet_mask[i])); // читаем байт в буфер  
		}
		for( i=0;i<=4;i++){                 // читаем ip шлюза подсети до тех пор пока не получим все 4 байт
     a2c:	10 92 7a 03 	sts	0x037A, r1
     a30:	16 c0       	rjmp	.+44     	; 0xa5e <main+0xd6>
		searash_gw[i]= eeprom_read_byte(&(ip_gw[i]));	// читаем байт в буфер  
     a32:	e0 91 7a 03 	lds	r30, 0x037A
     a36:	80 91 7a 03 	lds	r24, 0x037A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     a3a:	e1 99       	sbic	0x1c, 1	; 28
     a3c:	fe cf       	rjmp	.-4      	; 0xa3a <main+0xb2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	82 5e       	subi	r24, 0xE2	; 226
     a42:	9f 4f       	sbci	r25, 0xFF	; 255
     a44:	9f bb       	out	0x1f, r25	; 31
     a46:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     a48:	e0 9a       	sbi	0x1c, 0	; 28
     a4a:	8d b3       	in	r24, 0x1d	; 29
     a4c:	f0 e0       	ldi	r31, 0x00	; 0
     a4e:	ef 56       	subi	r30, 0x6F	; 111
     a50:	ff 4f       	sbci	r31, 0xFF	; 255
     a52:	80 83       	st	Z, r24
		myip_new[i]= eeprom_read_byte(&(myip[i]));	// читаем байт в буфер  
		}
		 for( i=0;i<=4;i++){                // читаем маску подсети до тех пор пока не получим все 4 байт
		searash_subnet[i]= eeprom_read_byte(&(subnet_mask[i])); // читаем байт в буфер  
		}
		for( i=0;i<=4;i++){                 // читаем ip шлюза подсети до тех пор пока не получим все 4 байт
     a54:	80 91 7a 03 	lds	r24, 0x037A
     a58:	8f 5f       	subi	r24, 0xFF	; 255
     a5a:	80 93 7a 03 	sts	0x037A, r24
     a5e:	80 91 7a 03 	lds	r24, 0x037A
     a62:	85 30       	cpi	r24, 0x05	; 5
     a64:	30 f3       	brcs	.-52     	; 0xa32 <main+0xaa>
     a66:	0c c0       	rjmp	.+24     	; 0xa80 <main+0xf8>
		//for( i=0;i<=6;i++){                 // читаем mac шлюза подсети до тех пор пока не получим все 4 байт
		//searash_mac_[i]= eeprom_read_byte(&(searash_mac[i]));	// читаем байт в буфер  
		//}
		
		while(y<4){
	    IP_GENERAL[y]=myip_new[y];
     a68:	e9 2f       	mov	r30, r25
     a6a:	f0 e0       	ldi	r31, 0x00	; 0
     a6c:	df 01       	movw	r26, r30
     a6e:	a4 55       	subi	r26, 0x54	; 84
     a70:	bc 4f       	sbci	r27, 0xFC	; 252
     a72:	8c 91       	ld	r24, X
     a74:	ed 55       	subi	r30, 0x5D	; 93
     a76:	ff 4f       	sbci	r31, 0xFF	; 255
     a78:	80 83       	st	Z, r24
			y++;
     a7a:	9f 5f       	subi	r25, 0xFF	; 255
     a7c:	90 93 7c 03 	sts	0x037C, r25
		}
		//for( i=0;i<=6;i++){                 // читаем mac шлюза подсети до тех пор пока не получим все 4 байт
		//searash_mac_[i]= eeprom_read_byte(&(searash_mac[i]));	// читаем байт в буфер  
		//}
		
		while(y<4){
     a80:	90 91 7c 03 	lds	r25, 0x037C
     a84:	94 30       	cpi	r25, 0x04	; 4
     a86:	80 f3       	brcs	.-32     	; 0xa68 <main+0xe0>
	    IP_GENERAL[y]=myip_new[y];
			y++;
			}
		 enc28j60Init(mymac);
     a88:	88 e8       	ldi	r24, 0x88	; 136
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	6c d6       	rcall	.+3288   	; 0x1766 <enc28j60Init>
		 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
     a8e:	82 e0       	ldi	r24, 0x02	; 2
     a90:	65 d6       	rcall	.+3274   	; 0x175c <enc28j60clkout>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     a92:	12 e3       	ldi	r17, 0x32	; 50
     a94:	81 2f       	mov	r24, r17
     a96:	8a 95       	dec	r24
     a98:	f1 f7       	brne	.-4      	; 0xa96 <main+0x10e>
        _delay_loop_1(50); // 12ms
	    enc28j60PhyWrite(PHLCON,0x476);
     a9a:	84 e1       	ldi	r24, 0x14	; 20
     a9c:	66 e7       	ldi	r22, 0x76	; 118
     a9e:	74 e0       	ldi	r23, 0x04	; 4
     aa0:	43 d6       	rcall	.+3206   	; 0x1728 <enc28j60PhyWrite>
     aa2:	1a 95       	dec	r17
     aa4:	f1 f7       	brne	.-4      	; 0xaa2 <main+0x11a>
        _delay_loop_1(50); // 12ms
        init_ip_arp_udp_tcp(mymac,myip_new,MYWWWPORT);
     aa6:	88 e8       	ldi	r24, 0x88	; 136
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	6c ea       	ldi	r22, 0xAC	; 172
     aac:	73 e0       	ldi	r23, 0x03	; 3
     aae:	40 e5       	ldi	r20, 0x50	; 80
     ab0:	7e d2       	rcall	.+1276   	; 0xfae <init_ip_arp_udp_tcp>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ab2:	c8 eb       	ldi	r28, 0xB8	; 184
     ab4:	db e0       	ldi	r29, 0x0B	; 11
       y++;
       } 				
      client_arp_whohas(buf_receive,searash_gw);  // шлем ARP ЗАПРОС
	 _delay_ms(1); // 1ms
	  enc28j60PacketReceive(ARP_BUFFER_SIZE,buf_ARP);   // принимаем пакет содержащий arp ответ
	  if(buf_ARP[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V ){   // если в поле ответ
     ab6:	42 e0       	ldi	r20, 0x02	; 2
     ab8:	d4 2e       	mov	r13, r20
				while(y<4){                         // Делаем & с маской подсети
				IP_GENERAL[y]&=searash_subnet[y];
				y++;
				} 
				 
                 flag=1;                           // сравниваем 
     aba:	cc 24       	eor	r12, r12
     abc:	c3 94       	inc	r12
	    //if(result) {ow_write_byte(OW_SKIP_ROM_CMD)	;	// если он есить  команда "пропустить адрес"
	   // }	
       

 while(1){
       if(time==1){   // примерно раз в минуту шлем arp для поиска шлюза
     abe:	80 91 90 00 	lds	r24, 0x0090
     ac2:	81 30       	cpi	r24, 0x01	; 1
     ac4:	09 f0       	breq	.+2      	; 0xac8 <main+0x140>
     ac6:	3f c0       	rjmp	.+126    	; 0xb46 <main+0x1be>
     ac8:	08 c0       	rjmp	.+16     	; 0xada <main+0x152>
	   while(y<ARP_BUFFER_SIZE ){
       buf_ARP[y]=0;
     aca:	e8 2f       	mov	r30, r24
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	e2 58       	subi	r30, 0x82	; 130
     ad0:	fc 4f       	sbci	r31, 0xFC	; 252
     ad2:	10 82       	st	Z, r1
       y++;
     ad4:	8f 5f       	subi	r24, 0xFF	; 255
     ad6:	80 93 7c 03 	sts	0x037C, r24
	   // }	
       

 while(1){
       if(time==1){   // примерно раз в минуту шлем arp для поиска шлюза
	   while(y<ARP_BUFFER_SIZE ){
     ada:	80 91 7c 03 	lds	r24, 0x037C
     ade:	8d 32       	cpi	r24, 0x2D	; 45
     ae0:	a0 f3       	brcs	.-24     	; 0xaca <main+0x142>
       buf_ARP[y]=0;
       y++;
       } 				
      client_arp_whohas(buf_receive,searash_gw);  // шлем ARP ЗАПРОС
     ae2:	8b e1       	ldi	r24, 0x1B	; 27
     ae4:	93 e0       	ldi	r25, 0x03	; 3
     ae6:	61 e9       	ldi	r22, 0x91	; 145
     ae8:	70 e0       	ldi	r23, 0x00	; 0
     aea:	cb d3       	rcall	.+1942   	; 0x1282 <client_arp_whohas>
     aec:	ce 01       	movw	r24, r28
     aee:	01 97       	sbiw	r24, 0x01	; 1
     af0:	f1 f7       	brne	.-4      	; 0xaee <main+0x166>
	 _delay_ms(1); // 1ms
	  enc28j60PacketReceive(ARP_BUFFER_SIZE,buf_ARP);   // принимаем пакет содержащий arp ответ
     af2:	8d e2       	ldi	r24, 0x2D	; 45
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	6e e7       	ldi	r22, 0x7E	; 126
     af8:	73 e0       	ldi	r23, 0x03	; 3
     afa:	46 d7       	rcall	.+3724   	; 0x1988 <enc28j60PacketReceive>
	  if(buf_ARP[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V ){   // если в поле ответ
     afc:	d0 92 93 03 	sts	0x0393, r13
	   y=0;
     b00:	10 92 7c 03 	sts	0x037C, r1
     b04:	0d c0       	rjmp	.+26     	; 0xb20 <main+0x198>
	  while(y<6){
       searash_mac_[y]=buf_ARP[ ETH_ARP_SRC_MAC_P+y];  // копируем содержимое ответа в буфер
     b06:	e9 2f       	mov	r30, r25
     b08:	f0 e0       	ldi	r31, 0x00	; 0
     b0a:	df 01       	movw	r26, r30
     b0c:	a2 58       	subi	r26, 0x82	; 130
     b0e:	bc 4f       	sbci	r27, 0xFC	; 252
     b10:	56 96       	adiw	r26, 0x16	; 22
     b12:	8c 91       	ld	r24, X
     b14:	e7 56       	subi	r30, 0x67	; 103
     b16:	ff 4f       	sbci	r31, 0xFF	; 255
     b18:	80 83       	st	Z, r24
      y++;
     b1a:	9f 5f       	subi	r25, 0xFF	; 255
     b1c:	90 93 7c 03 	sts	0x037C, r25
      client_arp_whohas(buf_receive,searash_gw);  // шлем ARP ЗАПРОС
	 _delay_ms(1); // 1ms
	  enc28j60PacketReceive(ARP_BUFFER_SIZE,buf_ARP);   // принимаем пакет содержащий arp ответ
	  if(buf_ARP[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V ){   // если в поле ответ
	   y=0;
	  while(y<6){
     b20:	90 91 7c 03 	lds	r25, 0x037C
     b24:	96 30       	cpi	r25, 0x06	; 6
     b26:	78 f3       	brcs	.-34     	; 0xb06 <main+0x17e>
     b28:	08 c0       	rjmp	.+16     	; 0xb3a <main+0x1b2>
       searash_mac_[y]=buf_ARP[ ETH_ARP_SRC_MAC_P+y];  // копируем содержимое ответа в буфер
      y++;
	  }
      while(y<ARP_BUFFER_SIZE ){
      buf_ARP[y]=0;
     b2a:	e8 2f       	mov	r30, r24
     b2c:	f0 e0       	ldi	r31, 0x00	; 0
     b2e:	e2 58       	subi	r30, 0x82	; 130
     b30:	fc 4f       	sbci	r31, 0xFC	; 252
     b32:	10 82       	st	Z, r1
      y++;
     b34:	8f 5f       	subi	r24, 0xFF	; 255
     b36:	80 93 7c 03 	sts	0x037C, r24
	   y=0;
	  while(y<6){
       searash_mac_[y]=buf_ARP[ ETH_ARP_SRC_MAC_P+y];  // копируем содержимое ответа в буфер
      y++;
	  }
      while(y<ARP_BUFFER_SIZE ){
     b3a:	80 91 7c 03 	lds	r24, 0x037C
     b3e:	8d 32       	cpi	r24, 0x2D	; 45
     b40:	a0 f3       	brcs	.-24     	; 0xb2a <main+0x1a2>
      buf_ARP[y]=0;
      y++;
      } 
	  }
      //eeprom_write_block(searash_mac_,searash_mac,6);   //пишем mac шлюза адрем в eeprom	 
	  time=0;
     b42:	10 92 90 00 	sts	0x0090, r1
      }
		   // flag=1;
		        data_receive(flag,searash_mac_);
     b46:	80 91 01 03 	lds	r24, 0x0301
     b4a:	90 e0       	ldi	r25, 0x00	; 0
     b4c:	69 e9       	ldi	r22, 0x99	; 153
     b4e:	70 e0       	ldi	r23, 0x00	; 0
     b50:	54 d2       	rcall	.+1192   	; 0xffa <data_receive>
                
                         if (!(PIN_reset & (1 <<  reset ))){    //  если кнопка нажата 
     b52:	9b 99       	sbic	0x13, 3	; 19
     b54:	75 c0       	rjmp	.+234    	; 0xc40 <main+0x2b8>
			//возвратим настройки по умолчанию 
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
     b56:	10 92 7a 03 	sts	0x037A, r1
     b5a:	16 c0       	rjmp	.+44     	; 0xb88 <main+0x200>
		        myip_new[i]= eeprom_read_byte(&(myip_reserve[i]));	// читаем байт в буфер 
     b5c:	e0 91 7a 03 	lds	r30, 0x037A
     b60:	80 91 7a 03 	lds	r24, 0x037A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     b64:	e1 99       	sbic	0x1c, 1	; 28
     b66:	fe cf       	rjmp	.-4      	; 0xb64 <main+0x1dc>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	8c 5f       	subi	r24, 0xFC	; 252
     b6c:	9f 4f       	sbci	r25, 0xFF	; 255
     b6e:	9f bb       	out	0x1f, r25	; 31
     b70:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     b72:	e0 9a       	sbi	0x1c, 0	; 28
     b74:	8d b3       	in	r24, 0x1d	; 29
     b76:	f0 e0       	ldi	r31, 0x00	; 0
     b78:	e4 55       	subi	r30, 0x54	; 84
     b7a:	fc 4f       	sbci	r31, 0xFC	; 252
     b7c:	80 83       	st	Z, r24
		   // flag=1;
		        data_receive(flag,searash_mac_);
                
                         if (!(PIN_reset & (1 <<  reset ))){    //  если кнопка нажата 
			//возвратим настройки по умолчанию 
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
     b7e:	80 91 7a 03 	lds	r24, 0x037A
     b82:	8f 5f       	subi	r24, 0xFF	; 255
     b84:	80 93 7a 03 	sts	0x037A, r24
     b88:	80 91 7a 03 	lds	r24, 0x037A
     b8c:	85 30       	cpi	r24, 0x05	; 5
     b8e:	30 f3       	brcs	.-52     	; 0xb5c <main+0x1d4>
		        myip_new[i]= eeprom_read_byte(&(myip_reserve[i]));	// читаем байт в буфер 
                }
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
     b90:	10 92 7a 03 	sts	0x037A, r1
     b94:	16 c0       	rjmp	.+44     	; 0xbc2 <main+0x23a>
		        searash_subnet[i]= eeprom_read_byte(&(searash_reserve_maska[i]));	// читаем байт в буфер  
     b96:	e0 91 7a 03 	lds	r30, 0x037A
     b9a:	80 91 7a 03 	lds	r24, 0x037A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     b9e:	e1 99       	sbic	0x1c, 1	; 28
     ba0:	fe cf       	rjmp	.-4      	; 0xb9e <main+0x216>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     ba2:	90 e0       	ldi	r25, 0x00	; 0
     ba4:	84 5f       	subi	r24, 0xF4	; 244
     ba6:	9f 4f       	sbci	r25, 0xFF	; 255
     ba8:	9f bb       	out	0x1f, r25	; 31
     baa:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     bac:	e0 9a       	sbi	0x1c, 0	; 28
     bae:	8d b3       	in	r24, 0x1d	; 29
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	eb 56       	subi	r30, 0x6B	; 107
     bb4:	ff 4f       	sbci	r31, 0xFF	; 255
     bb6:	80 83       	st	Z, r24
                         if (!(PIN_reset & (1 <<  reset ))){    //  если кнопка нажата 
			//возвратим настройки по умолчанию 
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
		        myip_new[i]= eeprom_read_byte(&(myip_reserve[i]));	// читаем байт в буфер 
                }
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
     bb8:	80 91 7a 03 	lds	r24, 0x037A
     bbc:	8f 5f       	subi	r24, 0xFF	; 255
     bbe:	80 93 7a 03 	sts	0x037A, r24
     bc2:	80 91 7a 03 	lds	r24, 0x037A
     bc6:	85 30       	cpi	r24, 0x05	; 5
     bc8:	30 f3       	brcs	.-52     	; 0xb96 <main+0x20e>
		        searash_subnet[i]= eeprom_read_byte(&(searash_reserve_maska[i]));	// читаем байт в буфер  
				}
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
     bca:	10 92 7a 03 	sts	0x037A, r1
     bce:	16 c0       	rjmp	.+44     	; 0xbfc <main+0x274>
		        searash_gw[i]= eeprom_read_byte(&(ip_gw_reserve[i]));	// читаем байт в буфер  
     bd0:	e0 91 7a 03 	lds	r30, 0x037A
     bd4:	80 91 7a 03 	lds	r24, 0x037A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     bd8:	e1 99       	sbic	0x1c, 1	; 28
     bda:	fe cf       	rjmp	.-4      	; 0xbd8 <main+0x250>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     bdc:	90 e0       	ldi	r25, 0x00	; 0
     bde:	80 5f       	subi	r24, 0xF0	; 240
     be0:	9f 4f       	sbci	r25, 0xFF	; 255
     be2:	9f bb       	out	0x1f, r25	; 31
     be4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     be6:	e0 9a       	sbi	0x1c, 0	; 28
     be8:	8d b3       	in	r24, 0x1d	; 29
     bea:	f0 e0       	ldi	r31, 0x00	; 0
     bec:	ef 56       	subi	r30, 0x6F	; 111
     bee:	ff 4f       	sbci	r31, 0xFF	; 255
     bf0:	80 83       	st	Z, r24
		        myip_new[i]= eeprom_read_byte(&(myip_reserve[i]));	// читаем байт в буфер 
                }
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
		        searash_subnet[i]= eeprom_read_byte(&(searash_reserve_maska[i]));	// читаем байт в буфер  
				}
				for( i=0;i<=4;i++){                 // читаем до тех пор пока не получим все 4 байт
     bf2:	80 91 7a 03 	lds	r24, 0x037A
     bf6:	8f 5f       	subi	r24, 0xFF	; 255
     bf8:	80 93 7a 03 	sts	0x037A, r24
     bfc:	80 91 7a 03 	lds	r24, 0x037A
     c00:	85 30       	cpi	r24, 0x05	; 5
     c02:	30 f3       	brcs	.-52     	; 0xbd0 <main+0x248>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
     c04:	8e e1       	ldi	r24, 0x1E	; 30
     c06:	90 e0       	ldi	r25, 0x00	; 0
     c08:	61 e9       	ldi	r22, 0x91	; 145
     c0a:	70 e0       	ldi	r23, 0x00	; 0
     c0c:	44 e0       	ldi	r20, 0x04	; 4
     c0e:	50 e0       	ldi	r21, 0x00	; 0
     c10:	2d e7       	ldi	r18, 0x7D	; 125
     c12:	32 e0       	ldi	r19, 0x02	; 2
     c14:	6f d7       	rcall	.+3806   	; 0x1af4 <__eewr_block>
				}
				eeprom_write_block(searash_gw,ip_gw,4);
				eeprom_write_block(searash_subnet,subnet_mask,4);
				eeprom_write_block(myip_new,myip,4);              //пишем новый IP адрем в eeprom\
				
				WDTCR = (1<<WDE);                                 // ЗАВОДИМ СОБАКУ
     c16:	88 e0       	ldi	r24, 0x08	; 8
     c18:	90 e0       	ldi	r25, 0x00	; 0
     c1a:	65 e9       	ldi	r22, 0x95	; 149
     c1c:	70 e0       	ldi	r23, 0x00	; 0
     c1e:	44 e0       	ldi	r20, 0x04	; 4
     c20:	50 e0       	ldi	r21, 0x00	; 0
     c22:	2d e7       	ldi	r18, 0x7D	; 125
     c24:	32 e0       	ldi	r19, 0x02	; 2
     c26:	66 d7       	rcall	.+3788   	; 0x1af4 <__eewr_block>
     c28:	80 e0       	ldi	r24, 0x00	; 0
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	6c ea       	ldi	r22, 0xAC	; 172
     c2e:	73 e0       	ldi	r23, 0x03	; 3
     c30:	44 e0       	ldi	r20, 0x04	; 4
     c32:	50 e0       	ldi	r21, 0x00	; 0
     c34:	2d e7       	ldi	r18, 0x7D	; 125
     c36:	32 e0       	ldi	r19, 0x02	; 2
     c38:	5d d7       	rcall	.+3770   	; 0x1af4 <__eewr_block>
     c3a:	88 e0       	ldi	r24, 0x08	; 8
     c3c:	81 bd       	out	0x21, r24	; 33
     c3e:	ff cf       	rjmp	.-2      	; 0xc3e <main+0x2b6>
                while(1);                                         // и ждем
			     
				}
				
                plen= enc28j60PacketReceive(BUFFER_SIZE, buf);// приеимаем пакет
     c40:	86 e2       	ldi	r24, 0x26	; 38
     c42:	92 e0       	ldi	r25, 0x02	; 2
     c44:	67 ea       	ldi	r22, 0xA7	; 167
     c46:	70 e0       	ldi	r23, 0x00	; 0
     c48:	9f d6       	rcall	.+3390   	; 0x1988 <enc28j60PacketReceive>
     c4a:	8c 01       	movw	r16, r24
  			
              
                if(plen==0){       // если длина равна 0 то вызодим
     c4c:	00 97       	sbiw	r24, 0x00	; 0
     c4e:	09 f4       	brne	.+2      	; 0xc52 <main+0x2ca>
     c50:	36 cf       	rjmp	.-404    	; 0xabe <main+0x136>
                        continue;
     c52:	f8 2e       	mov	r15, r24
     c54:	e1 2e       	mov	r14, r17
                }
				 y=0;// пишем в буфер ip адрес источника 
     c56:	10 92 7c 03 	sts	0x037C, r1
     c5a:	0d c0       	rjmp	.+26     	; 0xc76 <main+0x2ee>
				while(y<4){
                IP_SCR_CHAR[y]=buf[IP_SRC_P+y];
     c5c:	e9 2f       	mov	r30, r25
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	df 01       	movw	r26, r30
     c62:	a9 55       	subi	r26, 0x59	; 89
     c64:	bf 4f       	sbci	r27, 0xFF	; 255
     c66:	5a 96       	adiw	r26, 0x1a	; 26
     c68:	8c 91       	ld	r24, X
     c6a:	e2 59       	subi	r30, 0x92	; 146
     c6c:	fc 4f       	sbci	r31, 0xFC	; 252
     c6e:	80 83       	st	Z, r24
                   y++;
     c70:	9f 5f       	subi	r25, 0xFF	; 255
     c72:	90 93 7c 03 	sts	0x037C, r25
              
                if(plen==0){       // если длина равна 0 то вызодим
                        continue;
                }
				 y=0;// пишем в буфер ip адрес источника 
				while(y<4){
     c76:	90 91 7c 03 	lds	r25, 0x037C
     c7a:	94 30       	cpi	r25, 0x04	; 4
     c7c:	78 f3       	brcs	.-34     	; 0xc5c <main+0x2d4>
                IP_SCR_CHAR[y]=buf[IP_SRC_P+y];
                   y++;
                } 
              	//data_receive(flag,searash_mac_);
			   parse_ip(IP_SRC,IP_SCR_CHAR); 
     c7e:	8f e9       	ldi	r24, 0x9F	; 159
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	6e e6       	ldi	r22, 0x6E	; 110
     c84:	73 e0       	ldi	r23, 0x03	; 3
     c86:	51 dd       	rcall	.-1374   	; 0x72a <parse_ip>
				y=0;
     c88:	10 92 7c 03 	sts	0x037C, r1
     c8c:	0e c0       	rjmp	.+28     	; 0xcaa <main+0x322>
				while(y<4){                        // Делаем & с маской подсети
				IP_SRC[y]&=searash_subnet[y];
     c8e:	e2 2f       	mov	r30, r18
     c90:	f0 e0       	ldi	r31, 0x00	; 0
     c92:	df 01       	movw	r26, r30
     c94:	a1 56       	subi	r26, 0x61	; 97
     c96:	bf 4f       	sbci	r27, 0xFF	; 255
     c98:	eb 56       	subi	r30, 0x6B	; 107
     c9a:	ff 4f       	sbci	r31, 0xFF	; 255
     c9c:	80 81       	ld	r24, Z
     c9e:	9c 91       	ld	r25, X
     ca0:	89 23       	and	r24, r25
     ca2:	8c 93       	st	X, r24
				y++;
     ca4:	2f 5f       	subi	r18, 0xFF	; 255
     ca6:	20 93 7c 03 	sts	0x037C, r18
                   y++;
                } 
              	//data_receive(flag,searash_mac_);
			   parse_ip(IP_SRC,IP_SCR_CHAR); 
				y=0;
				while(y<4){                        // Делаем & с маской подсети
     caa:	20 91 7c 03 	lds	r18, 0x037C
     cae:	24 30       	cpi	r18, 0x04	; 4
     cb0:	70 f3       	brcs	.-36     	; 0xc8e <main+0x306>
				IP_SRC[y]&=searash_subnet[y];
				y++;
				}
				parse_ip(IP_GENERAL,IP_GENERAL_CHAR);
     cb2:	83 ea       	ldi	r24, 0xA3	; 163
     cb4:	90 e0       	ldi	r25, 0x00	; 0
     cb6:	66 e7       	ldi	r22, 0x76	; 118
     cb8:	73 e0       	ldi	r23, 0x03	; 3
     cba:	37 dd       	rcall	.-1426   	; 0x72a <parse_ip>
                 y=0;
     cbc:	10 92 7c 03 	sts	0x037C, r1
     cc0:	0e c0       	rjmp	.+28     	; 0xcde <main+0x356>
				while(y<4){                         // Делаем & с маской подсети
				IP_GENERAL[y]&=searash_subnet[y];
     cc2:	e2 2f       	mov	r30, r18
     cc4:	f0 e0       	ldi	r31, 0x00	; 0
     cc6:	df 01       	movw	r26, r30
     cc8:	ad 55       	subi	r26, 0x5D	; 93
     cca:	bf 4f       	sbci	r27, 0xFF	; 255
     ccc:	eb 56       	subi	r30, 0x6B	; 107
     cce:	ff 4f       	sbci	r31, 0xFF	; 255
     cd0:	80 81       	ld	r24, Z
     cd2:	9c 91       	ld	r25, X
     cd4:	89 23       	and	r24, r25
     cd6:	8c 93       	st	X, r24
				y++;
     cd8:	2f 5f       	subi	r18, 0xFF	; 255
     cda:	20 93 7c 03 	sts	0x037C, r18
				IP_SRC[y]&=searash_subnet[y];
				y++;
				}
				parse_ip(IP_GENERAL,IP_GENERAL_CHAR);
                 y=0;
				while(y<4){                         // Делаем & с маской подсети
     cde:	20 91 7c 03 	lds	r18, 0x037C
     ce2:	24 30       	cpi	r18, 0x04	; 4
     ce4:	70 f3       	brcs	.-36     	; 0xcc2 <main+0x33a>
				IP_GENERAL[y]&=searash_subnet[y];
				y++;
				} 
				 
                 flag=1;                           // сравниваем 
     ce6:	c0 92 01 03 	sts	0x0301, r12
               if(*IP_GENERAL!=*IP_SRC){
     cea:	90 91 a3 00 	lds	r25, 0x00A3
     cee:	80 91 9f 00 	lds	r24, 0x009F
     cf2:	98 17       	cp	r25, r24
     cf4:	11 f0       	breq	.+4      	; 0xcfa <main+0x372>
				flag=0;
     cf6:	10 92 01 03 	sts	0x0301, r1
				}
                       
               // иначе анализируем принятый пакет
                if(eth_type_is_arp_and_my_ip(buf,plen)){ // если  это arp то 
     cfa:	87 ea       	ldi	r24, 0xA7	; 167
     cfc:	90 e0       	ldi	r25, 0x00	; 0
     cfe:	6f 2d       	mov	r22, r15
     d00:	7e 2d       	mov	r23, r14
     d02:	8d d1       	rcall	.+794    	; 0x101e <eth_type_is_arp_and_my_ip>
     d04:	88 23       	and	r24, r24
     d06:	21 f0       	breq	.+8      	; 0xd10 <main+0x388>
                        make_arp_answer_from_request(buf);// шлем arp отклик
     d08:	87 ea       	ldi	r24, 0xA7	; 167
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	d8 d3       	rcall	.+1968   	; 0x14be <make_arp_answer_from_request>
     d0e:	d7 ce       	rjmp	.-594    	; 0xabe <main+0x136>
                        continue;
                }

                if(eth_type_is_ip_and_my_ip(buf,plen)==0){ // если принятый ip равен нашему 
     d10:	87 ea       	ldi	r24, 0xA7	; 167
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	6f 2d       	mov	r22, r15
     d16:	7e 2d       	mov	r23, r14
     d18:	9e d1       	rcall	.+828    	; 0x1056 <eth_type_is_ip_and_my_ip>
     d1a:	88 23       	and	r24, r24
     d1c:	09 f4       	brne	.+2      	; 0xd20 <main+0x398>
     d1e:	cf ce       	rjmp	.-610    	; 0xabe <main+0x136>
				
			
                

                // анализируем остальные поля
                if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V){
     d20:	80 91 be 00 	lds	r24, 0x00BE
     d24:	81 30       	cpi	r24, 0x01	; 1
     d26:	59 f4       	brne	.+22     	; 0xd3e <main+0x3b6>
     d28:	80 91 c9 00 	lds	r24, 0x00C9
     d2c:	88 30       	cpi	r24, 0x08	; 8
     d2e:	09 f0       	breq	.+2      	; 0xd32 <main+0x3aa>
     d30:	c6 ce       	rjmp	.-628    	; 0xabe <main+0x136>
                        // если это ping то делаем ответ
                        make_echo_reply_from_request(buf,plen);
     d32:	87 ea       	ldi	r24, 0xA7	; 167
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	6f 2d       	mov	r22, r15
     d38:	7e 2d       	mov	r23, r14
     d3a:	a6 d3       	rcall	.+1868   	; 0x1488 <make_echo_reply_from_request>
     d3c:	c0 ce       	rjmp	.-640    	; 0xabe <main+0x136>
                        continue;
                }
				// смотрим флаги пакета
                if (buf[IP_PROTO_P]==IP_PROTO_TCP_V&&buf[TCP_DST_PORT_H_P]==0&&buf[TCP_DST_PORT_L_P]==MYWWWPORT){
     d3e:	86 30       	cpi	r24, 0x06	; 6
     d40:	09 f0       	breq	.+2      	; 0xd44 <main+0x3bc>
     d42:	bd ce       	rjmp	.-646    	; 0xabe <main+0x136>
     d44:	80 91 cb 00 	lds	r24, 0x00CB
     d48:	88 23       	and	r24, r24
     d4a:	09 f0       	breq	.+2      	; 0xd4e <main+0x3c6>
     d4c:	b8 ce       	rjmp	.-656    	; 0xabe <main+0x136>
     d4e:	80 91 cc 00 	lds	r24, 0x00CC
     d52:	80 35       	cpi	r24, 0x50	; 80
     d54:	09 f0       	breq	.+2      	; 0xd58 <main+0x3d0>
     d56:	b3 ce       	rjmp	.-666    	; 0xabe <main+0x136>
                        if (buf[TCP_FLAGS_P] & TCP_FLAGS_SYN_V){
     d58:	80 91 d6 00 	lds	r24, 0x00D6
     d5c:	81 ff       	sbrs	r24, 1
     d5e:	04 c0       	rjmp	.+8      	; 0xd68 <main+0x3e0>
						// если пришел флаг TCP_FLAGS_SYN_V шлем  asc
                                make_tcp_synack_from_syn(buf);
     d60:	87 ea       	ldi	r24, 0xA7	; 167
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	28 d3       	rcall	.+1616   	; 0x13b6 <make_tcp_synack_from_syn>
     d66:	ab ce       	rjmp	.-682    	; 0xabe <main+0x136>
                          continue;
                        }
                        if (buf[TCP_FLAGS_P] & TCP_FLAGS_ACK_V){   // если получили TCP_FLAGS_ACK_V
     d68:	84 ff       	sbrs	r24, 4
     d6a:	a9 ce       	rjmp	.-686    	; 0xabe <main+0x136>
                                init_len_info(buf); // инициализиреум буфер
     d6c:	87 ea       	ldi	r24, 0xA7	; 167
     d6e:	90 e0       	ldi	r25, 0x00	; 0
     d70:	34 d2       	rcall	.+1128   	; 0x11da <init_len_info>
                               dat_p=get_tcp_data_pointer();
     d72:	22 d2       	rcall	.+1092   	; 0x11b8 <get_tcp_data_pointer>
								for (i=0;i<RECEIVE_BUFFER_SIZE;i++){  // заполняем buf_receive
     d74:	10 92 7a 03 	sts	0x037A, r1
     d78:	dc 01       	movw	r26, r24
     d7a:	a9 55       	subi	r26, 0x59	; 89
     d7c:	bf 4f       	sbci	r27, 0xFF	; 255
     d7e:	0c c0       	rjmp	.+24     	; 0xd98 <main+0x410>
								buf_receive[i]=buf[dat_p++];
     d80:	e0 91 7a 03 	lds	r30, 0x037A
     d84:	f0 e0       	ldi	r31, 0x00	; 0
     d86:	e5 5e       	subi	r30, 0xE5	; 229
     d88:	fc 4f       	sbci	r31, 0xFC	; 252
     d8a:	8d 91       	ld	r24, X+
     d8c:	80 83       	st	Z, r24
                          continue;
                        }
                        if (buf[TCP_FLAGS_P] & TCP_FLAGS_ACK_V){   // если получили TCP_FLAGS_ACK_V
                                init_len_info(buf); // инициализиреум буфер
                               dat_p=get_tcp_data_pointer();
								for (i=0;i<RECEIVE_BUFFER_SIZE;i++){  // заполняем buf_receive
     d8e:	80 91 7a 03 	lds	r24, 0x037A
     d92:	8f 5f       	subi	r24, 0xFF	; 255
     d94:	80 93 7a 03 	sts	0x037A, r24
     d98:	80 91 7a 03 	lds	r24, 0x037A
     d9c:	86 34       	cpi	r24, 0x46	; 70
     d9e:	80 f3       	brcs	.-32     	; 0xd80 <main+0x3f8>
								buf_receive[i]=buf[dat_p++];
								 }
								dat_p=get_tcp_data_pointer();
     da0:	0b d2       	rcall	.+1046   	; 0x11b8 <get_tcp_data_pointer>
     da2:	bc 01       	movw	r22, r24
                                if (dat_p==0){     // если данных нет шлем TCP_FLAGS_FIN_V
     da4:	00 97       	sbiw	r24, 0x00	; 0
     da6:	41 f4       	brne	.+16     	; 0xdb8 <main+0x430>
                                if (buf[TCP_FLAGS_P] & TCP_FLAGS_FIN_V){
     da8:	80 91 d6 00 	lds	r24, 0x00D6
     dac:	80 ff       	sbrs	r24, 0
     dae:	87 ce       	rjmp	.-754    	; 0xabe <main+0x136>
                                  make_tcp_ack_from_any(buf);
     db0:	87 ea       	ldi	r24, 0xA7	; 167
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	d7 d2       	rcall	.+1454   	; 0x1364 <make_tcp_ack_from_any>
     db6:	83 ce       	rjmp	.-762    	; 0xabe <main+0x136>
                                        }
										 continue;
                                }
						
                 	
				     if (strncmp("GET ",(char *)&(buf[dat_p]),4)==0){   // на предмет присутствия GET 
     db8:	69 55       	subi	r22, 0x59	; 89
     dba:	7f 4f       	sbci	r23, 0xFF	; 255
     dbc:	81 e8       	ldi	r24, 0x81	; 129
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	44 e0       	ldi	r20, 0x04	; 4
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	89 d6       	rcall	.+3346   	; 0x1ad8 <strncmp>
     dc6:	00 97       	sbiw	r24, 0x00	; 0
     dc8:	41 f4       	brne	.+16     	; 0xdda <main+0x452>
					 plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n")); 
     dca:	87 ea       	ldi	r24, 0xA7	; 167
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	60 e0       	ldi	r22, 0x00	; 0
     dd0:	70 e0       	ldi	r23, 0x00	; 0
     dd2:	4e e6       	ldi	r20, 0x6E	; 110
     dd4:	51 e0       	ldi	r21, 0x01	; 1
     dd6:	24 d2       	rcall	.+1096   	; 0x1220 <fill_tcp_data_p>
     dd8:	8c 01       	movw	r16, r24
					 // если все нормально шлем это
					 //plen=print_webpage(buf); 
                    }
					 // сдесь анализируем url
				    dat_p=0;
				    cmd=analyse_get_url((char *)&(buf_receive[dat_p+4])); 
     dda:	8f e1       	ldi	r24, 0x1F	; 31
     ddc:	93 e0       	ldi	r25, 0x03	; 3
     dde:	e5 dc       	rcall	.-1590   	; 0x7aa <analyse_get_url>
                    if(cmd==2){
     de0:	82 30       	cpi	r24, 0x02	; 2
     de2:	21 f4       	brne	.+8      	; 0xdec <main+0x464>
					plen=print_webpage(buf);
     de4:	87 ea       	ldi	r24, 0xA7	; 167
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	8d dd       	rcall	.-1254   	; 0x904 <print_webpage>
     dea:	54 c0       	rjmp	.+168    	; 0xe94 <main+0x50c>
				    }
					if( cmd==4 && pw_status==1){   // если введен адрес шлюза 
     dec:	84 30       	cpi	r24, 0x04	; 4
     dee:	89 f5       	brne	.+98     	; 0xe52 <main+0x4ca>
     df0:	80 91 ab 03 	lds	r24, 0x03AB
     df4:	81 30       	cpi	r24, 0x01	; 1
     df6:	99 f5       	brne	.+102    	; 0xe5e <main+0x4d6>
     df8:	8e e1       	ldi	r24, 0x1E	; 30
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	61 e9       	ldi	r22, 0x91	; 145
     dfe:	70 e0       	ldi	r23, 0x00	; 0
     e00:	44 e0       	ldi	r20, 0x04	; 4
     e02:	50 e0       	ldi	r21, 0x00	; 0
     e04:	2d e7       	ldi	r18, 0x7D	; 125
     e06:	32 e0       	ldi	r19, 0x02	; 2
     e08:	75 d6       	rcall	.+3306   	; 0x1af4 <__eewr_block>
				   // пишем все в eeprom
					//eeprom_write_block(searash_mac_,searash_mac,6);   //пишем mac шлюза адрем в eeprom
					eeprom_write_block(searash_gw,ip_gw,4);           //пишем IP шлюза адрем в eeprom
					eeprom_write_block(searash_subnet,subnet_mask,4); // пишем маску подсети в eeprom
				    eeprom_write_block(myip_new,myip,4);              //пишем новый IP адрем в eeprom
				    plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n<div ALIGN=CENTER> Все ОК"));
     e0a:	88 e0       	ldi	r24, 0x08	; 8
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	65 e9       	ldi	r22, 0x95	; 149
     e10:	70 e0       	ldi	r23, 0x00	; 0
     e12:	44 e0       	ldi	r20, 0x04	; 4
     e14:	50 e0       	ldi	r21, 0x00	; 0
     e16:	2d e7       	ldi	r18, 0x7D	; 125
     e18:	32 e0       	ldi	r19, 0x02	; 2
     e1a:	6c d6       	rcall	.+3288   	; 0x1af4 <__eewr_block>
     e1c:	80 e0       	ldi	r24, 0x00	; 0
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	6c ea       	ldi	r22, 0xAC	; 172
     e22:	73 e0       	ldi	r23, 0x03	; 3
     e24:	44 e0       	ldi	r20, 0x04	; 4
     e26:	50 e0       	ldi	r21, 0x00	; 0
     e28:	2d e7       	ldi	r18, 0x7D	; 125
     e2a:	32 e0       	ldi	r19, 0x02	; 2
     e2c:	63 d6       	rcall	.+3270   	; 0x1af4 <__eewr_block>
     e2e:	87 ea       	ldi	r24, 0xA7	; 167
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	60 e0       	ldi	r22, 0x00	; 0
     e34:	70 e0       	ldi	r23, 0x00	; 0
     e36:	48 e2       	ldi	r20, 0x28	; 40
     e38:	51 e0       	ldi	r21, 0x01	; 1
     e3a:	f2 d1       	rcall	.+996    	; 0x1220 <fill_tcp_data_p>
     e3c:	8c 01       	movw	r16, r24
					make_tcp_ack_from_any(buf); 
     e3e:	87 ea       	ldi	r24, 0xA7	; 167
     e40:	90 e0       	ldi	r25, 0x00	; 0
     e42:	90 d2       	rcall	.+1312   	; 0x1364 <make_tcp_ack_from_any>
                    make_tcp_ack_with_data(buf,plen); 
     e44:	87 ea       	ldi	r24, 0xA7	; 167
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	b8 01       	movw	r22, r16
     e4a:	65 d2       	rcall	.+1226   	; 0x1316 <make_tcp_ack_with_data>
	                WDTCR = (1<<WDE);                                 // ЗАВОДИМ СОБАКУ
     e4c:	88 e0       	ldi	r24, 0x08	; 8
     e4e:	81 bd       	out	0x21, r24	; 33
     e50:	ff cf       	rjmp	.-2      	; 0xe50 <main+0x4c8>
                    while(1);                                         // и ждем
					//} 
					//}
					}
					if(cmd==3){
     e52:	83 30       	cpi	r24, 0x03	; 3
     e54:	01 f5       	brne	.+64     	; 0xe96 <main+0x50e>
					plen=print_webpage_config(buf);
     e56:	87 ea       	ldi	r24, 0xA7	; 167
     e58:	90 e0       	ldi	r25, 0x00	; 0
     e5a:	fb db       	rcall	.-2058   	; 0x652 <print_webpage_config>
     e5c:	1b c0       	rjmp	.+54     	; 0xe94 <main+0x50c>
					}
					if( cmd==4 && pw_status==0){
     e5e:	88 23       	and	r24, r24
     e60:	11 f5       	brne	.+68     	; 0xea6 <main+0x51e>
					plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n <div ALIGN=CENTER>Вы ввели неверный пароль"));
     e62:	87 ea       	ldi	r24, 0xA7	; 167
     e64:	90 e0       	ldi	r25, 0x00	; 0
     e66:	60 e0       	ldi	r22, 0x00	; 0
     e68:	70 e0       	ldi	r23, 0x00	; 0
     e6a:	40 ed       	ldi	r20, 0xD0	; 208
     e6c:	50 e0       	ldi	r21, 0x00	; 0
     e6e:	d8 d1       	rcall	.+944    	; 0x1220 <fill_tcp_data_p>
     e70:	8c 01       	movw	r16, r24
     e72:	19 c0       	rjmp	.+50     	; 0xea6 <main+0x51e>
					}
					if( cmd==4 && pw_status==0){
					plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n <div ALIGN=CENTER>Вы ввели неверный пароль"));
     e74:	87 ea       	ldi	r24, 0xA7	; 167
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	60 e0       	ldi	r22, 0x00	; 0
     e7a:	70 e0       	ldi	r23, 0x00	; 0
     e7c:	48 e7       	ldi	r20, 0x78	; 120
     e7e:	50 e0       	ldi	r21, 0x00	; 0
     e80:	cf d1       	rcall	.+926    	; 0x1220 <fill_tcp_data_p>
     e82:	8c 01       	movw	r16, r24
     e84:	14 c0       	rjmp	.+40     	; 0xeae <main+0x526>
					}
					if( cmd==4 && pw_status==2){
					plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n <div ALIGN=CENTER>Вы не ввели пароль"));
     e86:	87 ea       	ldi	r24, 0xA7	; 167
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	60 e0       	ldi	r22, 0x00	; 0
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	46 e2       	ldi	r20, 0x26	; 38
     e90:	50 e0       	ldi	r21, 0x00	; 0
     e92:	c6 d1       	rcall	.+908    	; 0x1220 <fill_tcp_data_p>
     e94:	8c 01       	movw	r16, r24
					}
					
					goto SENDTCP;
SENDTCP:
                    make_tcp_ack_from_any(buf);                        // отправляем ack 
     e96:	87 ea       	ldi	r24, 0xA7	; 167
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	64 d2       	rcall	.+1224   	; 0x1364 <make_tcp_ack_from_any>
                    make_tcp_ack_with_data(buf,plen);                  // передаем наши данные
     e9c:	87 ea       	ldi	r24, 0xA7	; 167
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	b8 01       	movw	r22, r16
     ea2:	39 d2       	rcall	.+1138   	; 0x1316 <make_tcp_ack_with_data>
     ea4:	0c ce       	rjmp	.-1000   	; 0xabe <main+0x136>
					plen=print_webpage_config(buf);
					}
					if( cmd==4 && pw_status==0){
					plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n <div ALIGN=CENTER>Вы ввели неверный пароль"));
					}
					if( cmd==4 && pw_status==0){
     ea6:	80 91 ab 03 	lds	r24, 0x03AB
     eaa:	88 23       	and	r24, r24
     eac:	19 f3       	breq	.-58     	; 0xe74 <main+0x4ec>
					plen=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n <div ALIGN=CENTER>Вы ввели неверный пароль"));
					}
					if( cmd==4 && pw_status==2){
     eae:	80 91 ab 03 	lds	r24, 0x03AB
     eb2:	82 30       	cpi	r24, 0x02	; 2
     eb4:	81 f7       	brne	.-32     	; 0xe96 <main+0x50e>
     eb6:	e7 cf       	rjmp	.-50     	; 0xe86 <main+0x4fe>

00000eb8 <checksum>:
//
// For more information on how this algorithm works see:
// http://www.netfor2.com/checksum.html
// http://www.msc.uky.edu/ken/cs471/notes/chap3.htm
// The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
uint16_t checksum(uint8_t *buf, uint16_t len,uint8_t type){
     eb8:	cf 92       	push	r12
     eba:	df 92       	push	r13
     ebc:	ef 92       	push	r14
     ebe:	ff 92       	push	r15
     ec0:	0f 93       	push	r16
     ec2:	1f 93       	push	r17
     ec4:	cf 93       	push	r28
     ec6:	df 93       	push	r29
     ec8:	6c 01       	movw	r12, r24
        uint32_t sum = 0;

        //if(type==0){
        //        // do not add anything
        //}
        if(type==1){
     eca:	41 30       	cpi	r20, 0x01	; 1
     ecc:	81 f4       	brne	.+32     	; 0xeee <checksum+0x36>
                sum+=IP_PROTO_UDP_V; // protocol udp
                // the length here is the length of udp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
     ece:	68 50       	subi	r22, 0x08	; 8
     ed0:	70 40       	sbci	r23, 0x00	; 0
     ed2:	7b 01       	movw	r14, r22
     ed4:	00 e0       	ldi	r16, 0x00	; 0
     ed6:	10 e0       	ldi	r17, 0x00	; 0
     ed8:	68 5f       	subi	r22, 0xF8	; 248
     eda:	7f 4f       	sbci	r23, 0xFF	; 255
     edc:	21 e1       	ldi	r18, 0x11	; 17
     ede:	30 e0       	ldi	r19, 0x00	; 0
     ee0:	40 e0       	ldi	r20, 0x00	; 0
     ee2:	50 e0       	ldi	r21, 0x00	; 0
     ee4:	e2 0e       	add	r14, r18
     ee6:	f3 1e       	adc	r15, r19
     ee8:	04 1f       	adc	r16, r20
     eea:	15 1f       	adc	r17, r21
     eec:	15 c0       	rjmp	.+42     	; 0xf18 <checksum+0x60>
        }
        if(type==2){
     eee:	42 30       	cpi	r20, 0x02	; 2
     ef0:	21 f0       	breq	.+8      	; 0xefa <checksum+0x42>
     ef2:	ee 24       	eor	r14, r14
     ef4:	ff 24       	eor	r15, r15
     ef6:	87 01       	movw	r16, r14
     ef8:	0f c0       	rjmp	.+30     	; 0xf18 <checksum+0x60>
                sum+=IP_PROTO_TCP_V; 
                // the length here is the length of tcp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
     efa:	68 50       	subi	r22, 0x08	; 8
     efc:	70 40       	sbci	r23, 0x00	; 0
     efe:	7b 01       	movw	r14, r22
     f00:	00 e0       	ldi	r16, 0x00	; 0
     f02:	10 e0       	ldi	r17, 0x00	; 0
     f04:	68 5f       	subi	r22, 0xF8	; 248
     f06:	7f 4f       	sbci	r23, 0xFF	; 255
     f08:	86 e0       	ldi	r24, 0x06	; 6
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	a0 e0       	ldi	r26, 0x00	; 0
     f0e:	b0 e0       	ldi	r27, 0x00	; 0
     f10:	e8 0e       	add	r14, r24
     f12:	f9 1e       	adc	r15, r25
     f14:	0a 1f       	adc	r16, r26
     f16:	1b 1f       	adc	r17, r27
     f18:	f6 01       	movw	r30, r12
     f1a:	eb 01       	movw	r28, r22
     f1c:	16 c0       	rjmp	.+44     	; 0xf4a <checksum+0x92>
        }
        // build the sum of 16bit words
        while(len >1){
                sum += 0xFFFF & (((uint32_t)*buf<<8)|*(buf+1));
     f1e:	80 81       	ld	r24, Z
     f20:	90 e0       	ldi	r25, 0x00	; 0
     f22:	a0 e0       	ldi	r26, 0x00	; 0
     f24:	b0 e0       	ldi	r27, 0x00	; 0
     f26:	ba 2f       	mov	r27, r26
     f28:	a9 2f       	mov	r26, r25
     f2a:	98 2f       	mov	r25, r24
     f2c:	88 27       	eor	r24, r24
     f2e:	21 81       	ldd	r18, Z+1	; 0x01
     f30:	30 e0       	ldi	r19, 0x00	; 0
     f32:	40 e0       	ldi	r20, 0x00	; 0
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	82 2b       	or	r24, r18
     f38:	93 2b       	or	r25, r19
     f3a:	a4 2b       	or	r26, r20
     f3c:	b5 2b       	or	r27, r21
     f3e:	e8 0e       	add	r14, r24
     f40:	f9 1e       	adc	r15, r25
     f42:	0a 1f       	adc	r16, r26
     f44:	1b 1f       	adc	r17, r27
                buf+=2;
     f46:	32 96       	adiw	r30, 0x02	; 2
                len-=2;
     f48:	22 97       	sbiw	r28, 0x02	; 2
                // the length here is the length of tcp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
        }
        // build the sum of 16bit words
        while(len >1){
     f4a:	c2 30       	cpi	r28, 0x02	; 2
     f4c:	d1 05       	cpc	r29, r1
     f4e:	38 f7       	brcc	.-50     	; 0xf1e <checksum+0x66>
     f50:	fb 01       	movw	r30, r22
     f52:	ee 7f       	andi	r30, 0xFE	; 254
     f54:	ec 0d       	add	r30, r12
     f56:	fd 1d       	adc	r31, r13
                sum += 0xFFFF & (((uint32_t)*buf<<8)|*(buf+1));
                buf+=2;
                len-=2;
        }
        // if there is a byte left then add it (padded with zero)
        if (len){
     f58:	60 ff       	sbrs	r22, 0
     f5a:	15 c0       	rjmp	.+42     	; 0xf86 <checksum+0xce>
                sum += ((uint32_t)(0xFF & *buf))<<8;
     f5c:	80 81       	ld	r24, Z
     f5e:	90 e0       	ldi	r25, 0x00	; 0
     f60:	a0 e0       	ldi	r26, 0x00	; 0
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	ba 2f       	mov	r27, r26
     f66:	a9 2f       	mov	r26, r25
     f68:	98 2f       	mov	r25, r24
     f6a:	88 27       	eor	r24, r24
     f6c:	08 c0       	rjmp	.+16     	; 0xf7e <checksum+0xc6>
        }
        // now calculate the sum over the bytes in the sum
        // until the result is only 16bit long
        while (sum>>16){
                sum = (sum & 0xFFFF)+(sum >> 16);
     f6e:	2f ef       	ldi	r18, 0xFF	; 255
     f70:	3f ef       	ldi	r19, 0xFF	; 255
     f72:	40 e0       	ldi	r20, 0x00	; 0
     f74:	50 e0       	ldi	r21, 0x00	; 0
     f76:	e2 22       	and	r14, r18
     f78:	f3 22       	and	r15, r19
     f7a:	04 23       	and	r16, r20
     f7c:	15 23       	and	r17, r21
     f7e:	e8 0e       	add	r14, r24
     f80:	f9 1e       	adc	r15, r25
     f82:	0a 1f       	adc	r16, r26
     f84:	1b 1f       	adc	r17, r27
        if (len){
                sum += ((uint32_t)(0xFF & *buf))<<8;
        }
        // now calculate the sum over the bytes in the sum
        // until the result is only 16bit long
        while (sum>>16){
     f86:	c8 01       	movw	r24, r16
     f88:	aa 27       	eor	r26, r26
     f8a:	bb 27       	eor	r27, r27
     f8c:	00 97       	sbiw	r24, 0x00	; 0
     f8e:	a1 05       	cpc	r26, r1
     f90:	b1 05       	cpc	r27, r1
     f92:	69 f7       	brne	.-38     	; 0xf6e <checksum+0xb6>
     f94:	97 01       	movw	r18, r14
     f96:	20 95       	com	r18
     f98:	30 95       	com	r19
                sum = (sum & 0xFFFF)+(sum >> 16);
        }
        // build 1's complement:
        return( (uint16_t) sum ^ 0xFFFF);
}
     f9a:	c9 01       	movw	r24, r18
     f9c:	df 91       	pop	r29
     f9e:	cf 91       	pop	r28
     fa0:	1f 91       	pop	r17
     fa2:	0f 91       	pop	r16
     fa4:	ff 90       	pop	r15
     fa6:	ef 90       	pop	r14
     fa8:	df 90       	pop	r13
     faa:	cf 90       	pop	r12
     fac:	08 95       	ret

00000fae <init_ip_arp_udp_tcp>:

// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint8_t wwwp){
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	ec 01       	movw	r28, r24
        uint8_t i=0;
        wwwport=wwwp;
     fb4:	40 93 8e 00 	sts	0x008E, r20
     fb8:	20 e0       	ldi	r18, 0x00	; 0
     fba:	30 e0       	ldi	r19, 0x00	; 0
        while(i<4){
                ipaddr[i]=myip[i];
     fbc:	f9 01       	movw	r30, r18
     fbe:	e4 5f       	subi	r30, 0xF4	; 244
     fc0:	fc 4f       	sbci	r31, 0xFC	; 252
     fc2:	db 01       	movw	r26, r22
     fc4:	a2 0f       	add	r26, r18
     fc6:	b3 1f       	adc	r27, r19
     fc8:	8c 91       	ld	r24, X
     fca:	80 83       	st	Z, r24
     fcc:	2f 5f       	subi	r18, 0xFF	; 255
     fce:	3f 4f       	sbci	r19, 0xFF	; 255

// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint8_t wwwp){
        uint8_t i=0;
        wwwport=wwwp;
        while(i<4){
     fd0:	24 30       	cpi	r18, 0x04	; 4
     fd2:	31 05       	cpc	r19, r1
     fd4:	99 f7       	brne	.-26     	; 0xfbc <init_ip_arp_udp_tcp+0xe>
     fd6:	20 e0       	ldi	r18, 0x00	; 0
     fd8:	30 e0       	ldi	r19, 0x00	; 0
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
                macaddr[i]=mymac[i];
     fda:	f9 01       	movw	r30, r18
     fdc:	ea 5f       	subi	r30, 0xFA	; 250
     fde:	fc 4f       	sbci	r31, 0xFC	; 252
     fe0:	de 01       	movw	r26, r28
     fe2:	a2 0f       	add	r26, r18
     fe4:	b3 1f       	adc	r27, r19
     fe6:	8c 91       	ld	r24, X
     fe8:	80 83       	st	Z, r24
     fea:	2f 5f       	subi	r18, 0xFF	; 255
     fec:	3f 4f       	sbci	r19, 0xFF	; 255
        while(i<4){
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
     fee:	26 30       	cpi	r18, 0x06	; 6
     ff0:	31 05       	cpc	r19, r1
     ff2:	99 f7       	brne	.-26     	; 0xfda <init_ip_arp_udp_tcp+0x2c>
                macaddr[i]=mymac[i];
                i++;
        }
}
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	08 95       	ret

00000ffa <data_receive>:
void data_receive(uint8_t flag,uint8_t *searash_mac_){
    uint8_t i=0;
	flag_gw=flag;
     ffa:	80 93 b9 03 	sts	0x03B9, r24
     ffe:	20 e0       	ldi	r18, 0x00	; 0
    1000:	30 e0       	ldi	r19, 0x00	; 0
	while(i<6){
                
               macaddr_gw[i]=searash_mac_[i];
    1002:	f9 01       	movw	r30, r18
    1004:	e0 5f       	subi	r30, 0xF0	; 240
    1006:	fc 4f       	sbci	r31, 0xFC	; 252
    1008:	db 01       	movw	r26, r22
    100a:	a2 0f       	add	r26, r18
    100c:	b3 1f       	adc	r27, r19
    100e:	8c 91       	ld	r24, X
    1010:	80 83       	st	Z, r24
    1012:	2f 5f       	subi	r18, 0xFF	; 255
    1014:	3f 4f       	sbci	r19, 0xFF	; 255
        }
}
void data_receive(uint8_t flag,uint8_t *searash_mac_){
    uint8_t i=0;
	flag_gw=flag;
	while(i<6){
    1016:	26 30       	cpi	r18, 0x06	; 6
    1018:	31 05       	cpc	r19, r1
    101a:	99 f7       	brne	.-26     	; 0x1002 <data_receive+0x8>
                
               macaddr_gw[i]=searash_mac_[i];
                i++;
				}
				}
    101c:	08 95       	ret

0000101e <eth_type_is_arp_and_my_ip>:
uint8_t eth_type_is_arp_and_my_ip(uint8_t *buf,uint16_t len){
    101e:	fc 01       	movw	r30, r24
        uint8_t i=0;
        //  
        if (len<41){
    1020:	69 32       	cpi	r22, 0x29	; 41
    1022:	71 05       	cpc	r23, r1
    1024:	b0 f0       	brcs	.+44     	; 0x1052 <eth_type_is_arp_and_my_ip+0x34>
                return(0);
        }
        if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || 
    1026:	84 85       	ldd	r24, Z+12	; 0x0c
    1028:	88 30       	cpi	r24, 0x08	; 8
    102a:	99 f4       	brne	.+38     	; 0x1052 <eth_type_is_arp_and_my_ip+0x34>
    102c:	85 85       	ldd	r24, Z+13	; 0x0d
    102e:	86 30       	cpi	r24, 0x06	; 6
    1030:	81 f4       	brne	.+32     	; 0x1052 <eth_type_is_arp_and_my_ip+0x34>
    1032:	df 01       	movw	r26, r30
    1034:	96 96       	adiw	r26, 0x26	; 38
    1036:	ec e0       	ldi	r30, 0x0C	; 12
    1038:	f3 e0       	ldi	r31, 0x03	; 3
           buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V){
                return(0);
        }
        while(i<4){
                if(buf[ETH_ARP_DST_IP_P+i] != ipaddr[i]){
    103a:	9c 91       	ld	r25, X
    103c:	80 81       	ld	r24, Z
    103e:	98 17       	cp	r25, r24
    1040:	41 f4       	brne	.+16     	; 0x1052 <eth_type_is_arp_and_my_ip+0x34>
    1042:	11 96       	adiw	r26, 0x01	; 1
    1044:	31 96       	adiw	r30, 0x01	; 1
        }
        if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || 
           buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V){
                return(0);
        }
        while(i<4){
    1046:	83 e0       	ldi	r24, 0x03	; 3
    1048:	e0 31       	cpi	r30, 0x10	; 16
    104a:	f8 07       	cpc	r31, r24
    104c:	b1 f7       	brne	.-20     	; 0x103a <eth_type_is_arp_and_my_ip+0x1c>
    104e:	81 e0       	ldi	r24, 0x01	; 1
    1050:	08 95       	ret
    1052:	80 e0       	ldi	r24, 0x00	; 0
                        return(0);
                }
                i++;
        }
        return(1);
}
    1054:	08 95       	ret

00001056 <eth_type_is_ip_and_my_ip>:
// если принятый ip равен нашему то все нормально
uint8_t eth_type_is_ip_and_my_ip(uint8_t *buf,uint16_t len){
    1056:	fc 01       	movw	r30, r24
        uint8_t i=0;
        //eth+ip+udp header is 42
        if (len<42){
    1058:	6a 32       	cpi	r22, 0x2A	; 42
    105a:	71 05       	cpc	r23, r1
    105c:	d0 f0       	brcs	.+52     	; 0x1092 <eth_type_is_ip_and_my_ip+0x3c>
                return(0);
        }
        if(buf[ETH_TYPE_H_P]!=ETHTYPE_IP_H_V || 
    105e:	84 85       	ldd	r24, Z+12	; 0x0c
    1060:	88 30       	cpi	r24, 0x08	; 8
    1062:	b9 f4       	brne	.+46     	; 0x1092 <eth_type_is_ip_and_my_ip+0x3c>
    1064:	85 85       	ldd	r24, Z+13	; 0x0d
    1066:	88 23       	and	r24, r24
    1068:	a1 f4       	brne	.+40     	; 0x1092 <eth_type_is_ip_and_my_ip+0x3c>
           buf[ETH_TYPE_L_P]!=ETHTYPE_IP_L_V){
                return(0);
        }
        if (buf[IP_HEADER_LEN_VER_P]!=0x45){
    106a:	86 85       	ldd	r24, Z+14	; 0x0e
    106c:	85 34       	cpi	r24, 0x45	; 69
    106e:	89 f4       	brne	.+34     	; 0x1092 <eth_type_is_ip_and_my_ip+0x3c>
    1070:	df 01       	movw	r26, r30
    1072:	ec e0       	ldi	r30, 0x0C	; 12
    1074:	f3 e0       	ldi	r31, 0x03	; 3
                // must be IP V4 and 20 byte header
                return(0);
        }
        while(i<4){
                if(buf[IP_DST_P+i]!=ipaddr[i]){
    1076:	5e 96       	adiw	r26, 0x1e	; 30
    1078:	9c 91       	ld	r25, X
    107a:	5e 97       	sbiw	r26, 0x1e	; 30
    107c:	80 81       	ld	r24, Z
    107e:	98 17       	cp	r25, r24
    1080:	41 f4       	brne	.+16     	; 0x1092 <eth_type_is_ip_and_my_ip+0x3c>
    1082:	11 96       	adiw	r26, 0x01	; 1
    1084:	31 96       	adiw	r30, 0x01	; 1
        }
        if (buf[IP_HEADER_LEN_VER_P]!=0x45){
                // must be IP V4 and 20 byte header
                return(0);
        }
        while(i<4){
    1086:	83 e0       	ldi	r24, 0x03	; 3
    1088:	e0 31       	cpi	r30, 0x10	; 16
    108a:	f8 07       	cpc	r31, r24
    108c:	a1 f7       	brne	.-24     	; 0x1076 <eth_type_is_ip_and_my_ip+0x20>
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	08 95       	ret
    1092:	80 e0       	ldi	r24, 0x00	; 0
                        return(0);
                }
                i++;
        }
        return(1);
}
    1094:	08 95       	ret

00001096 <make_eth>:
// make a return eth header from a received eth packet
void make_eth(uint8_t *buf)
{
    1096:	bc 01       	movw	r22, r24
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
		if(flag_gw==1){
    1098:	80 91 b9 03 	lds	r24, 0x03B9
    109c:	81 30       	cpi	r24, 0x01	; 1
    109e:	11 f0       	breq	.+4      	; 0x10a4 <make_eth+0xe>
    10a0:	40 e0       	ldi	r20, 0x00	; 0
    10a2:	0d c0       	rjmp	.+26     	; 0x10be <make_eth+0x28>
    10a4:	fb 01       	movw	r30, r22
    10a6:	a6 e0       	ldi	r26, 0x06	; 6
    10a8:	b3 e0       	ldi	r27, 0x03	; 3
		 while(i<6){
                buf[ETH_DST_MAC +i]= buf[ETH_SRC_MAC +i];
    10aa:	86 81       	ldd	r24, Z+6	; 0x06
    10ac:	80 83       	st	Z, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
    10ae:	8d 91       	ld	r24, X+
    10b0:	86 83       	std	Z+6, r24	; 0x06
    10b2:	31 96       	adiw	r30, 0x01	; 1
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
		if(flag_gw==1){
		 while(i<6){
    10b4:	83 e0       	ldi	r24, 0x03	; 3
    10b6:	ac 30       	cpi	r26, 0x0C	; 12
    10b8:	b8 07       	cpc	r27, r24
    10ba:	b9 f7       	brne	.-18     	; 0x10aa <make_eth+0x14>
    10bc:	46 e0       	ldi	r20, 0x06	; 6
                buf[ETH_DST_MAC +i]= buf[ETH_SRC_MAC +i];
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
		}
		if(flag_gw==0){
    10be:	80 91 b9 03 	lds	r24, 0x03B9
    10c2:	88 23       	and	r24, r24
    10c4:	91 f0       	breq	.+36     	; 0x10ea <make_eth+0x54>
    10c6:	08 95       	ret
        while(i<6){
                buf[ETH_DST_MAC +i]= macaddr_gw[i];//buf[ETH_SRC_MAC +i];
    10c8:	e4 2f       	mov	r30, r20
    10ca:	f0 e0       	ldi	r31, 0x00	; 0
    10cc:	9b 01       	movw	r18, r22
    10ce:	2e 0f       	add	r18, r30
    10d0:	3f 1f       	adc	r19, r31
    10d2:	df 01       	movw	r26, r30
    10d4:	a0 5f       	subi	r26, 0xF0	; 240
    10d6:	bc 4f       	sbci	r27, 0xFC	; 252
    10d8:	8c 91       	ld	r24, X
    10da:	d9 01       	movw	r26, r18
    10dc:	8c 93       	st	X, r24
                buf[ETH_SRC_MAC +i]=macaddr[i];
    10de:	ea 5f       	subi	r30, 0xFA	; 250
    10e0:	fc 4f       	sbci	r31, 0xFC	; 252
    10e2:	80 81       	ld	r24, Z
    10e4:	16 96       	adiw	r26, 0x06	; 6
    10e6:	8c 93       	st	X, r24
                i++;
    10e8:	4f 5f       	subi	r20, 0xFF	; 255
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
		}
		if(flag_gw==0){
        while(i<6){
    10ea:	46 30       	cpi	r20, 0x06	; 6
    10ec:	68 f3       	brcs	.-38     	; 0x10c8 <make_eth+0x32>
    10ee:	08 95       	ret

000010f0 <fill_ip_hdr_checksum>:
                i++;
        }
		}
}
void fill_ip_hdr_checksum(uint8_t *buf)
{
    10f0:	0f 93       	push	r16
    10f2:	1f 93       	push	r17
    10f4:	8c 01       	movw	r16, r24
        uint16_t ck;
        // clear the 2 byte checksum
        buf[IP_CHECKSUM_P]=0;
    10f6:	fc 01       	movw	r30, r24
    10f8:	10 8e       	std	Z+24, r1	; 0x18
        buf[IP_CHECKSUM_P+1]=0;
    10fa:	11 8e       	std	Z+25, r1	; 0x19
        buf[IP_FLAGS_P]=0x40; // don't fragment
    10fc:	80 e4       	ldi	r24, 0x40	; 64
    10fe:	84 8b       	std	Z+20, r24	; 0x14
        buf[IP_FLAGS_P+1]=0;  // fragement offset
    1100:	15 8a       	std	Z+21, r1	; 0x15
        buf[IP_TTL_P]=64; // ttl
    1102:	86 8b       	std	Z+22, r24	; 0x16
        // calculate the checksum:
        ck=checksum(&buf[IP_P], IP_HEADER_LEN,0);
    1104:	c8 01       	movw	r24, r16
    1106:	0e 96       	adiw	r24, 0x0e	; 14
    1108:	64 e1       	ldi	r22, 0x14	; 20
    110a:	70 e0       	ldi	r23, 0x00	; 0
    110c:	40 e0       	ldi	r20, 0x00	; 0
    110e:	d4 de       	rcall	.-600    	; 0xeb8 <checksum>
        buf[IP_CHECKSUM_P]=ck>>8;
    1110:	f8 01       	movw	r30, r16
    1112:	90 8f       	std	Z+24, r25	; 0x18
        buf[IP_CHECKSUM_P+1]=ck& 0xff;
    1114:	81 8f       	std	Z+25, r24	; 0x19
}
    1116:	1f 91       	pop	r17
    1118:	0f 91       	pop	r16
    111a:	08 95       	ret

0000111c <make_ip>:

// make a return ip header from a received ip packet
void make_ip(uint8_t *buf)
{
    111c:	ac 01       	movw	r20, r24
    111e:	fc 01       	movw	r30, r24
    1120:	ac e0       	ldi	r26, 0x0C	; 12
    1122:	b3 e0       	ldi	r27, 0x03	; 3
        uint8_t i=0;
        while(i<4){
                buf[IP_DST_P+i]=buf[IP_SRC_P+i];
    1124:	82 8d       	ldd	r24, Z+26	; 0x1a
    1126:	86 8f       	std	Z+30, r24	; 0x1e
                buf[IP_SRC_P+i]=ipaddr[i];
    1128:	8d 91       	ld	r24, X+
    112a:	82 8f       	std	Z+26, r24	; 0x1a
    112c:	31 96       	adiw	r30, 0x01	; 1

// make a return ip header from a received ip packet
void make_ip(uint8_t *buf)
{
        uint8_t i=0;
        while(i<4){
    112e:	83 e0       	ldi	r24, 0x03	; 3
    1130:	a0 31       	cpi	r26, 0x10	; 16
    1132:	b8 07       	cpc	r27, r24
    1134:	b9 f7       	brne	.-18     	; 0x1124 <make_ip+0x8>
                buf[IP_DST_P+i]=buf[IP_SRC_P+i];
                buf[IP_SRC_P+i]=ipaddr[i];
                i++;
        }
        fill_ip_hdr_checksum(buf);
    1136:	ca 01       	movw	r24, r20
    1138:	db df       	rcall	.-74     	; 0x10f0 <fill_ip_hdr_checksum>
}
    113a:	08 95       	ret

0000113c <make_tcphead>:
//
// After calling this function you can fill in the first data byte at TCP_OPTIONS_P+4
// If cp_seq=0 then an initial sequence number is used (should be use in synack)
// otherwise it is copied from the packet we received
void make_tcphead(uint8_t *buf,uint16_t rel_ack_num,uint8_t mss,uint8_t cp_seq)
{
    113c:	fc 01       	movw	r30, r24
        uint8_t i=0;
        uint8_t tseq;
        while(i<2){
                buf[TCP_DST_PORT_H_P+i]=buf[TCP_SRC_PORT_H_P+i];
    113e:	82 a1       	ldd	r24, Z+34	; 0x22
    1140:	84 a3       	std	Z+36, r24	; 0x24
                buf[TCP_SRC_PORT_H_P+i]=0; // clear source port
    1142:	12 a2       	std	Z+34, r1	; 0x22
void make_tcphead(uint8_t *buf,uint16_t rel_ack_num,uint8_t mss,uint8_t cp_seq)
{
        uint8_t i=0;
        uint8_t tseq;
        while(i<2){
                buf[TCP_DST_PORT_H_P+i]=buf[TCP_SRC_PORT_H_P+i];
    1144:	83 a1       	ldd	r24, Z+35	; 0x23
    1146:	85 a3       	std	Z+37, r24	; 0x25
                buf[TCP_SRC_PORT_H_P+i]=0; // clear source port
    1148:	13 a2       	std	Z+35, r1	; 0x23
                i++;
        }
        // set source port  (http):
        buf[TCP_SRC_PORT_L_P]=wwwport;
    114a:	80 91 8e 00 	lds	r24, 0x008E
    114e:	83 a3       	std	Z+35, r24	; 0x23
//
// After calling this function you can fill in the first data byte at TCP_OPTIONS_P+4
// If cp_seq=0 then an initial sequence number is used (should be use in synack)
// otherwise it is copied from the packet we received
void make_tcphead(uint8_t *buf,uint16_t rel_ack_num,uint8_t mss,uint8_t cp_seq)
{
    1150:	df 01       	movw	r26, r30
    1152:	99 96       	adiw	r26, 0x29	; 41
    1154:	94 e0       	ldi	r25, 0x04	; 4
        buf[TCP_SRC_PORT_L_P]=wwwport;
        i=4;
        // sequence numbers:
        // add the rel ack num to SEQACK
        while(i>0){
                rel_ack_num=buf[TCP_SEQ_H_P+i-1]+rel_ack_num;
    1156:	8c 91       	ld	r24, X
    1158:	68 0f       	add	r22, r24
    115a:	71 1d       	adc	r23, r1
                tseq=buf[TCP_SEQACK_H_P+i-1];
    115c:	14 96       	adiw	r26, 0x04	; 4
    115e:	8c 91       	ld	r24, X
    1160:	14 97       	sbiw	r26, 0x04	; 4
                buf[TCP_SEQACK_H_P+i-1]=0xff&rel_ack_num;
    1162:	14 96       	adiw	r26, 0x04	; 4
    1164:	6c 93       	st	X, r22
    1166:	14 97       	sbiw	r26, 0x04	; 4
                if (cp_seq){
    1168:	22 23       	and	r18, r18
    116a:	11 f0       	breq	.+4      	; 0x1170 <make_tcphead+0x34>
                        // copy the acknum sent to us into the sequence number
                        buf[TCP_SEQ_H_P+i-1]=tseq;
    116c:	8c 93       	st	X, r24
    116e:	01 c0       	rjmp	.+2      	; 0x1172 <make_tcphead+0x36>
                }else{
                        buf[TCP_SEQ_H_P+i-1]= 0; // some preset vallue
    1170:	1c 92       	st	X, r1
                }
                rel_ack_num=rel_ack_num>>8;
                i--;
    1172:	91 50       	subi	r25, 0x01	; 1
    1174:	11 97       	sbiw	r26, 0x01	; 1
        // set source port  (http):
        buf[TCP_SRC_PORT_L_P]=wwwport;
        i=4;
        // sequence numbers:
        // add the rel ack num to SEQACK
        while(i>0){
    1176:	99 23       	and	r25, r25
    1178:	19 f0       	breq	.+6      	; 0x1180 <make_tcphead+0x44>
                        // copy the acknum sent to us into the sequence number
                        buf[TCP_SEQ_H_P+i-1]=tseq;
                }else{
                        buf[TCP_SEQ_H_P+i-1]= 0; // some preset vallue
                }
                rel_ack_num=rel_ack_num>>8;
    117a:	67 2f       	mov	r22, r23
    117c:	77 27       	eor	r23, r23
    117e:	eb cf       	rjmp	.-42     	; 0x1156 <make_tcphead+0x1a>
                i--;
        }
        if (cp_seq==0){
    1180:	22 23       	and	r18, r18
    1182:	49 f4       	brne	.+18     	; 0x1196 <make_tcphead+0x5a>
                // put inital seq number
                buf[TCP_SEQ_H_P+0]= 0;
    1184:	16 a2       	std	Z+38, r1	; 0x26
                buf[TCP_SEQ_H_P+1]= 0;
    1186:	17 a2       	std	Z+39, r1	; 0x27
                // we step only the second byte, this allows us to send packts 
                // with 255 bytes or 512 (if we step the initial seqnum by 2)
                buf[TCP_SEQ_H_P+2]= seqnum; 
    1188:	80 91 8f 00 	lds	r24, 0x008F
    118c:	80 a7       	std	Z+40, r24	; 0x28
                buf[TCP_SEQ_H_P+3]= 0;
    118e:	11 a6       	std	Z+41, r1	; 0x29
                // step the inititial seq num by something we will not use
                // during this tcp session:
                seqnum+=2;
    1190:	8e 5f       	subi	r24, 0xFE	; 254
    1192:	80 93 8f 00 	sts	0x008F, r24
        }
        // zero the checksum
        buf[TCP_CHECKSUM_H_P]=0;
    1196:	12 aa       	std	Z+50, r1	; 0x32
        buf[TCP_CHECKSUM_L_P]=0;
    1198:	13 aa       	std	Z+51, r1	; 0x33

        // The tcp header length is only a 4 bit field (the upper 4 bits).
        // It is calculated in units of 4 bytes. 
        // E.g 24 bytes: 24/4=6 => 0x60=header len field
        //buf[TCP_HEADER_LEN_P]=(((TCP_HEADER_LEN_PLAIN+4)/4)) <<4; // 0x60
        if (mss){
    119a:	44 23       	and	r20, r20
    119c:	51 f0       	breq	.+20     	; 0x11b2 <make_tcphead+0x76>
                // the only option we set is MSS to 1408:
                // 1408 in hex is 0x580
                buf[TCP_OPTIONS_P]=2;
    119e:	82 e0       	ldi	r24, 0x02	; 2
    11a0:	86 ab       	std	Z+54, r24	; 0x36
                buf[TCP_OPTIONS_P+1]=4;
    11a2:	84 e0       	ldi	r24, 0x04	; 4
    11a4:	87 ab       	std	Z+55, r24	; 0x37
                buf[TCP_OPTIONS_P+2]=0x05; 
    11a6:	85 e0       	ldi	r24, 0x05	; 5
    11a8:	80 af       	std	Z+56, r24	; 0x38
                buf[TCP_OPTIONS_P+3]=0x80;
    11aa:	80 e8       	ldi	r24, 0x80	; 128
    11ac:	81 af       	std	Z+57, r24	; 0x39
                // 24 bytes:
                buf[TCP_HEADER_LEN_P]=0x60;
    11ae:	80 e6       	ldi	r24, 0x60	; 96
    11b0:	01 c0       	rjmp	.+2      	; 0x11b4 <make_tcphead+0x78>
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
    11b2:	80 e5       	ldi	r24, 0x50	; 80
    11b4:	86 a7       	std	Z+46, r24	; 0x2e
    11b6:	08 95       	ret

000011b8 <get_tcp_data_pointer>:
// get a pointer to the start of tcp data in buf
// Returns 0 if there is no data
// You must call init_len_info once before calling this function
uint16_t get_tcp_data_pointer(void)
{
        if (info_data_len){
    11b8:	80 91 02 03 	lds	r24, 0x0302
    11bc:	90 91 03 03 	lds	r25, 0x0303
    11c0:	89 2b       	or	r24, r25
    11c2:	19 f4       	brne	.+6      	; 0x11ca <get_tcp_data_pointer+0x12>
    11c4:	20 e0       	ldi	r18, 0x00	; 0
    11c6:	30 e0       	ldi	r19, 0x00	; 0
    11c8:	06 c0       	rjmp	.+12     	; 0x11d6 <get_tcp_data_pointer+0x1e>
                return((uint16_t)TCP_SRC_PORT_H_P+info_hdr_len);
    11ca:	20 91 04 03 	lds	r18, 0x0304
    11ce:	30 91 05 03 	lds	r19, 0x0305
    11d2:	2e 5d       	subi	r18, 0xDE	; 222
    11d4:	3f 4f       	sbci	r19, 0xFF	; 255
        }else{
                return(0);
        }
}
    11d6:	c9 01       	movw	r24, r18
    11d8:	08 95       	ret

000011da <init_len_info>:

// do some basic length calculations and store the result in static varibales
void init_len_info(uint8_t *buf)
{
    11da:	fc 01       	movw	r30, r24
        info_data_len=(((int16_t)buf[IP_TOTLEN_H_P])<<8)|(buf[IP_TOTLEN_L_P]&0xff);
    11dc:	90 89       	ldd	r25, Z+16	; 0x10
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	21 89       	ldd	r18, Z+17	; 0x11
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	28 2b       	or	r18, r24
    11e6:	39 2b       	or	r19, r25
        info_data_len-=IP_HEADER_LEN;
        info_hdr_len=(buf[TCP_HEADER_LEN_P]>>4)*4; // generate len in bytes;
    11e8:	86 a5       	ldd	r24, Z+46	; 0x2e
    11ea:	82 95       	swap	r24
    11ec:	8f 70       	andi	r24, 0x0F	; 15
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	88 0f       	add	r24, r24
    11f2:	99 1f       	adc	r25, r25
    11f4:	88 0f       	add	r24, r24
    11f6:	99 1f       	adc	r25, r25
    11f8:	90 93 05 03 	sts	0x0305, r25
    11fc:	80 93 04 03 	sts	0x0304, r24
        info_data_len-=info_hdr_len;
    1200:	24 51       	subi	r18, 0x14	; 20
    1202:	30 40       	sbci	r19, 0x00	; 0
    1204:	28 1b       	sub	r18, r24
    1206:	39 0b       	sbc	r19, r25
    1208:	30 93 03 03 	sts	0x0303, r19
    120c:	20 93 02 03 	sts	0x0302, r18
        if (info_data_len<=0){
    1210:	12 16       	cp	r1, r18
    1212:	13 06       	cpc	r1, r19
    1214:	24 f0       	brlt	.+8      	; 0x121e <init_len_info+0x44>
                info_data_len=0;
    1216:	10 92 03 03 	sts	0x0303, r1
    121a:	10 92 02 03 	sts	0x0302, r1
    121e:	08 95       	ret

00001220 <fill_tcp_data_p>:

// fill in tcp data at position pos. pos=0 means start of
// tcp data. Returns the position at which the string after
// this string could be filled.
uint16_t fill_tcp_data_p(uint8_t *buf,uint16_t pos, const prog_char *progmem_s)
{
    1220:	6a 5c       	subi	r22, 0xCA	; 202
    1222:	7f 4f       	sbci	r23, 0xFF	; 255
    1224:	dc 01       	movw	r26, r24
    1226:	a6 0f       	add	r26, r22
    1228:	b7 1f       	adc	r27, r23
    122a:	66 53       	subi	r22, 0x36	; 54
    122c:	70 40       	sbci	r23, 0x00	; 0
    122e:	03 c0       	rjmp	.+6      	; 0x1236 <fill_tcp_data_p+0x16>
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    1230:	8d 93       	st	X+, r24
                pos++;
    1232:	6f 5f       	subi	r22, 0xFF	; 255
    1234:	7f 4f       	sbci	r23, 0xFF	; 255
    1236:	fa 01       	movw	r30, r20
{
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    1238:	4f 5f       	subi	r20, 0xFF	; 255
    123a:	5f 4f       	sbci	r21, 0xFF	; 255
    123c:	84 91       	lpm	r24, Z+
    123e:	88 23       	and	r24, r24
    1240:	b9 f7       	brne	.-18     	; 0x1230 <fill_tcp_data_p+0x10>
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
                pos++;
        }
        return(pos);
}
    1242:	cb 01       	movw	r24, r22
    1244:	08 95       	ret

00001246 <fill_tcp_data>:

// fill in tcp data at position pos. pos=0 means start of
// tcp data. Returns the position at which the string after
// this string could be filled.
uint16_t fill_tcp_data(uint8_t *buf,uint16_t pos, const char *s)
{
    1246:	fa 01       	movw	r30, r20
    1248:	6a 5c       	subi	r22, 0xCA	; 202
    124a:	7f 4f       	sbci	r23, 0xFF	; 255
    124c:	dc 01       	movw	r26, r24
    124e:	a6 0f       	add	r26, r22
    1250:	b7 1f       	adc	r27, r23
    1252:	66 53       	subi	r22, 0x36	; 54
    1254:	70 40       	sbci	r23, 0x00	; 0
    1256:	04 c0       	rjmp	.+8      	; 0x1260 <fill_tcp_data+0x1a>
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
                buf[TCP_CHECKSUM_L_P+3+pos]=*s;
    1258:	8d 93       	st	X+, r24
                pos++;
    125a:	6f 5f       	subi	r22, 0xFF	; 255
    125c:	7f 4f       	sbci	r23, 0xFF	; 255
                s++;
    125e:	31 96       	adiw	r30, 0x01	; 1
uint16_t fill_tcp_data(uint8_t *buf,uint16_t pos, const char *s)
{
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (*s) {
    1260:	80 81       	ld	r24, Z
    1262:	88 23       	and	r24, r24
    1264:	c9 f7       	brne	.-14     	; 0x1258 <fill_tcp_data+0x12>
                buf[TCP_CHECKSUM_L_P+3+pos]=*s;
                pos++;
                s++;
        }
        return(pos);
}
    1266:	cb 01       	movw	r24, r22
    1268:	08 95       	ret

0000126a <fill_buf_p>:
        buf[TCP_CHECKSUM_H_P]=j>>8;
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
}
void fill_buf_p(uint8_t *buf,uint16_t len, const prog_char *progmem_s)
{
    126a:	dc 01       	movw	r26, r24
    126c:	fa 01       	movw	r30, r20
    126e:	05 c0       	rjmp	.+10     	; 0x127a <fill_buf_p+0x10>
        while (len){
                *buf= pgm_read_byte(progmem_s);
    1270:	84 91       	lpm	r24, Z+
    1272:	8d 93       	st	X+, r24
                buf++;
                progmem_s++;
    1274:	31 96       	adiw	r30, 0x01	; 1
                len--;
    1276:	61 50       	subi	r22, 0x01	; 1
    1278:	70 40       	sbci	r23, 0x00	; 0
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
}
void fill_buf_p(uint8_t *buf,uint16_t len, const prog_char *progmem_s)
{
        while (len){
    127a:	61 15       	cp	r22, r1
    127c:	71 05       	cpc	r23, r1
    127e:	c1 f7       	brne	.-16     	; 0x1270 <fill_buf_p+0x6>
                *buf= pgm_read_byte(progmem_s);
                buf++;
                progmem_s++;
                len--;
        }
} 
    1280:	08 95       	ret

00001282 <client_arp_whohas>:
void client_arp_whohas(uint8_t *buf,uint8_t *ip_we_search)
{
    1282:	cf 93       	push	r28
    1284:	df 93       	push	r29
    1286:	ec 01       	movw	r28, r24
    1288:	ac 01       	movw	r20, r24
    128a:	26 e0       	ldi	r18, 0x06	; 6
    128c:	33 e0       	ldi	r19, 0x03	; 3
    128e:	fc 01       	movw	r30, r24
    1290:	d9 01       	movw	r26, r18
        uint8_t i=0;
        //
        while(i<6){
                buf[ETH_DST_MAC +i]=0xff;
    1292:	9f ef       	ldi	r25, 0xFF	; 255
    1294:	90 83       	st	Z, r25
                buf[ETH_SRC_MAC +i]=macaddr[i];
    1296:	8d 91       	ld	r24, X+
    1298:	86 83       	std	Z+6, r24	; 0x06
    129a:	31 96       	adiw	r30, 0x01	; 1
} 
void client_arp_whohas(uint8_t *buf,uint8_t *ip_we_search)
{
        uint8_t i=0;
        //
        while(i<6){
    129c:	83 e0       	ldi	r24, 0x03	; 3
    129e:	ac 30       	cpi	r26, 0x0C	; 12
    12a0:	b8 07       	cpc	r27, r24
    12a2:	c1 f7       	brne	.-16     	; 0x1294 <client_arp_whohas+0x12>
                buf[ETH_DST_MAC +i]=0xff;
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
        buf[ETH_TYPE_H_P] = ETHTYPE_ARP_H_V;
    12a4:	88 e0       	ldi	r24, 0x08	; 8
    12a6:	8c 87       	std	Y+12, r24	; 0x0c
        buf[ETH_TYPE_L_P] = ETHTYPE_ARP_L_V;
    12a8:	86 e0       	ldi	r24, 0x06	; 6
    12aa:	8d 87       	std	Y+13, r24	; 0x0d
    12ac:	de 01       	movw	r26, r28
    12ae:	e9 eb       	ldi	r30, 0xB9	; 185
    12b0:	f4 e0       	ldi	r31, 0x04	; 4
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
}
void fill_buf_p(uint8_t *buf,uint16_t len, const prog_char *progmem_s)
{
        while (len){
                *buf= pgm_read_byte(progmem_s);
    12b2:	84 91       	lpm	r24, Z+
    12b4:	1e 96       	adiw	r26, 0x0e	; 14
    12b6:	8c 93       	st	X, r24
    12b8:	1e 97       	sbiw	r26, 0x0e	; 14
                buf++;
                progmem_s++;
    12ba:	31 96       	adiw	r30, 0x01	; 1
    12bc:	11 96       	adiw	r26, 0x01	; 1
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
}
void fill_buf_p(uint8_t *buf,uint16_t len, const prog_char *progmem_s)
{
        while (len){
    12be:	84 e0       	ldi	r24, 0x04	; 4
    12c0:	e1 3c       	cpi	r30, 0xC1	; 193
    12c2:	f8 07       	cpc	r31, r24
    12c4:	b1 f7       	brne	.-20     	; 0x12b2 <client_arp_whohas+0x30>
        buf[ETH_TYPE_H_P] = ETHTYPE_ARP_H_V;
        buf[ETH_TYPE_L_P] = ETHTYPE_ARP_L_V;
        fill_buf_p(&buf[ETH_ARP_P],8,arpreqhdr);
        i=0;
        while(i<6){
                buf[ETH_ARP_SRC_MAC_P +i]=macaddr[i];
    12c6:	f9 01       	movw	r30, r18
    12c8:	81 91       	ld	r24, Z+
    12ca:	9f 01       	movw	r18, r30
    12cc:	fa 01       	movw	r30, r20
    12ce:	86 8b       	std	Z+22, r24	; 0x16
                buf[ETH_ARP_DST_MAC_P+i]=0;
    12d0:	10 a2       	std	Z+32, r1	; 0x20
    12d2:	4f 5f       	subi	r20, 0xFF	; 255
    12d4:	5f 4f       	sbci	r21, 0xFF	; 255
        }
        buf[ETH_TYPE_H_P] = ETHTYPE_ARP_H_V;
        buf[ETH_TYPE_L_P] = ETHTYPE_ARP_L_V;
        fill_buf_p(&buf[ETH_ARP_P],8,arpreqhdr);
        i=0;
        while(i<6){
    12d6:	f3 e0       	ldi	r31, 0x03	; 3
    12d8:	2c 30       	cpi	r18, 0x0C	; 12
    12da:	3f 07       	cpc	r19, r31
    12dc:	a1 f7       	brne	.-24     	; 0x12c6 <client_arp_whohas+0x44>
    12de:	de 01       	movw	r26, r28
    12e0:	5c 96       	adiw	r26, 0x1c	; 28
    12e2:	20 e0       	ldi	r18, 0x00	; 0
    12e4:	30 e0       	ldi	r19, 0x00	; 0
                buf[ETH_ARP_DST_MAC_P+i]=0;
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=*(ip_we_search +i);
    12e6:	fb 01       	movw	r30, r22
    12e8:	e2 0f       	add	r30, r18
    12ea:	f3 1f       	adc	r31, r19
    12ec:	80 81       	ld	r24, Z
    12ee:	1a 96       	adiw	r26, 0x0a	; 10
    12f0:	8c 93       	st	X, r24
    12f2:	1a 97       	sbiw	r26, 0x0a	; 10
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    12f4:	f9 01       	movw	r30, r18
    12f6:	e4 5f       	subi	r30, 0xF4	; 244
    12f8:	fc 4f       	sbci	r31, 0xFC	; 252
    12fa:	80 81       	ld	r24, Z
    12fc:	8d 93       	st	X+, r24
    12fe:	2f 5f       	subi	r18, 0xFF	; 255
    1300:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[ETH_ARP_SRC_MAC_P +i]=macaddr[i];
                buf[ETH_ARP_DST_MAC_P+i]=0;
                i++;
        }
        i=0;
        while(i<4){
    1302:	24 30       	cpi	r18, 0x04	; 4
    1304:	31 05       	cpc	r19, r1
    1306:	79 f7       	brne	.-34     	; 0x12e6 <client_arp_whohas+0x64>
                buf[ETH_ARP_DST_IP_P+i]=*(ip_we_search +i);
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // 0x2a=42=len of packet
        enc28j60PacketSend(0x2a,buf);
    1308:	8a e2       	ldi	r24, 0x2A	; 42
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	be 01       	movw	r22, r28
    130e:	d1 d2       	rcall	.+1442   	; 0x18b2 <enc28j60PacketSend>
}
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	08 95       	ret

00001316 <make_tcp_ack_with_data>:
// dlen is the amount of tcp data (http data) we send in this packet
// You can use this function only immediately after make_tcp_ack_from_any
// This is because this function will NOT modify the eth/ip/tcp header except for
// length and checksum
void make_tcp_ack_with_data(uint8_t *buf,uint16_t dlen)
{
    1316:	ef 92       	push	r14
    1318:	ff 92       	push	r15
    131a:	0f 93       	push	r16
    131c:	1f 93       	push	r17
    131e:	8c 01       	movw	r16, r24
    1320:	7b 01       	movw	r14, r22
        uint16_t j;
        // fill the header:
        // This code requires that we send only one data packet
        // because we keep no state information. We must therefore set
        // the fin here:
        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
    1322:	89 e1       	ldi	r24, 0x19	; 25
    1324:	f8 01       	movw	r30, r16
    1326:	87 a7       	std	Z+47, r24	; 0x2f

        // total length field in the IP header must be set:
        // 20 bytes IP + 20 bytes tcp (when no options) + len of data
        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen;
    1328:	cb 01       	movw	r24, r22
    132a:	88 96       	adiw	r24, 0x28	; 40
        buf[IP_TOTLEN_H_P]=j>>8;
    132c:	90 8b       	std	Z+16, r25	; 0x10
        buf[IP_TOTLEN_L_P]=j& 0xff;
    132e:	81 8b       	std	Z+17, r24	; 0x11
        fill_ip_hdr_checksum(buf);
    1330:	c8 01       	movw	r24, r16
    1332:	de de       	rcall	.-580    	; 0x10f0 <fill_ip_hdr_checksum>
        // zero the checksum
        buf[TCP_CHECKSUM_H_P]=0;
    1334:	f8 01       	movw	r30, r16
    1336:	12 aa       	std	Z+50, r1	; 0x32
        buf[TCP_CHECKSUM_L_P]=0;
    1338:	13 aa       	std	Z+51, r1	; 0x33
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+dlen,2);
    133a:	8c e1       	ldi	r24, 0x1C	; 28
    133c:	90 e0       	ldi	r25, 0x00	; 0
    133e:	e8 0e       	add	r14, r24
    1340:	f9 1e       	adc	r15, r25
    1342:	c8 01       	movw	r24, r16
    1344:	4a 96       	adiw	r24, 0x1a	; 26
    1346:	b7 01       	movw	r22, r14
    1348:	42 e0       	ldi	r20, 0x02	; 2
    134a:	b6 dd       	rcall	.-1172   	; 0xeb8 <checksum>
        buf[TCP_CHECKSUM_H_P]=j>>8;
    134c:	f8 01       	movw	r30, r16
    134e:	92 ab       	std	Z+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
    1350:	83 ab       	std	Z+51, r24	; 0x33
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
    1352:	c7 01       	movw	r24, r14
    1354:	4a 96       	adiw	r24, 0x1a	; 26
    1356:	b8 01       	movw	r22, r16
    1358:	ac d2       	rcall	.+1368   	; 0x18b2 <enc28j60PacketSend>
}
    135a:	1f 91       	pop	r17
    135c:	0f 91       	pop	r16
    135e:	ff 90       	pop	r15
    1360:	ef 90       	pop	r14
    1362:	08 95       	ret

00001364 <make_tcp_ack_from_any>:
}

// Make just an ack packet with no tcp data inside
// This will modify the eth/ip/tcp header 
void make_tcp_ack_from_any(uint8_t *buf)
{
    1364:	cf 93       	push	r28
    1366:	df 93       	push	r29
    1368:	ec 01       	movw	r28, r24
        uint16_t j;
        make_eth(buf);
    136a:	95 de       	rcall	.-726    	; 0x1096 <make_eth>
        // fill the header:
        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V;
    136c:	80 e1       	ldi	r24, 0x10	; 16
    136e:	8f a7       	std	Y+47, r24	; 0x2f
        if (info_data_len==0){
    1370:	60 91 02 03 	lds	r22, 0x0302
    1374:	70 91 03 03 	lds	r23, 0x0303
    1378:	61 15       	cp	r22, r1
    137a:	71 05       	cpc	r23, r1
    137c:	21 f4       	brne	.+8      	; 0x1386 <make_tcp_ack_from_any+0x22>
                // if there is no data then we must still acknoledge one packet
                make_tcphead(buf,1,0,1); // no options
    137e:	ce 01       	movw	r24, r28
    1380:	61 e0       	ldi	r22, 0x01	; 1
    1382:	70 e0       	ldi	r23, 0x00	; 0
    1384:	01 c0       	rjmp	.+2      	; 0x1388 <make_tcp_ack_from_any+0x24>
        }else{
                make_tcphead(buf,info_data_len,0,1); // no options
    1386:	ce 01       	movw	r24, r28
    1388:	40 e0       	ldi	r20, 0x00	; 0
    138a:	21 e0       	ldi	r18, 0x01	; 1
    138c:	d7 de       	rcall	.-594    	; 0x113c <make_tcphead>
        }

        // total length field in the IP header must be set:
        // 20 bytes IP + 20 bytes tcp (when no options) 
        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN;
        buf[IP_TOTLEN_H_P]=j>>8;
    138e:	18 8a       	std	Y+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=j& 0xff;
    1390:	88 e2       	ldi	r24, 0x28	; 40
    1392:	89 8b       	std	Y+17, r24	; 0x11
        make_ip(buf);
    1394:	ce 01       	movw	r24, r28
    1396:	c2 de       	rcall	.-636    	; 0x111c <make_ip>
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN,2);
    1398:	ce 01       	movw	r24, r28
    139a:	4a 96       	adiw	r24, 0x1a	; 26
    139c:	6c e1       	ldi	r22, 0x1C	; 28
    139e:	70 e0       	ldi	r23, 0x00	; 0
    13a0:	42 e0       	ldi	r20, 0x02	; 2
    13a2:	8a dd       	rcall	.-1260   	; 0xeb8 <checksum>
        buf[TCP_CHECKSUM_H_P]=j>>8;
    13a4:	9a ab       	std	Y+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
    13a6:	8b ab       	std	Y+51, r24	; 0x33
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN,buf);
    13a8:	86 e3       	ldi	r24, 0x36	; 54
    13aa:	90 e0       	ldi	r25, 0x00	; 0
    13ac:	be 01       	movw	r22, r28
    13ae:	81 d2       	rcall	.+1282   	; 0x18b2 <enc28j60PacketSend>
}
    13b0:	df 91       	pop	r29
    13b2:	cf 91       	pop	r28
    13b4:	08 95       	ret

000013b6 <make_tcp_synack_from_syn>:
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
}

void make_tcp_synack_from_syn(uint8_t *buf)
{
    13b6:	0f 93       	push	r16
    13b8:	1f 93       	push	r17
    13ba:	8c 01       	movw	r16, r24
        uint16_t ck;
        make_eth(buf);
    13bc:	6c de       	rcall	.-808    	; 0x1096 <make_eth>
        // total length field in the IP header must be set:
        // 20 bytes IP + 24 bytes (20tcp+4tcp options)
        buf[IP_TOTLEN_H_P]=0;
    13be:	f8 01       	movw	r30, r16
    13c0:	10 8a       	std	Z+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4;
    13c2:	8c e2       	ldi	r24, 0x2C	; 44
    13c4:	81 8b       	std	Z+17, r24	; 0x11
        make_ip(buf);
    13c6:	c8 01       	movw	r24, r16
    13c8:	a9 de       	rcall	.-686    	; 0x111c <make_ip>
        buf[TCP_FLAGS_P]=TCP_FLAGS_SYNACK_V;
    13ca:	82 e1       	ldi	r24, 0x12	; 18
    13cc:	f8 01       	movw	r30, r16
    13ce:	87 a7       	std	Z+47, r24	; 0x2f
        make_tcphead(buf,1,1,0);
    13d0:	c8 01       	movw	r24, r16
    13d2:	61 e0       	ldi	r22, 0x01	; 1
    13d4:	70 e0       	ldi	r23, 0x00	; 0
    13d6:	41 e0       	ldi	r20, 0x01	; 1
    13d8:	20 e0       	ldi	r18, 0x00	; 0
    13da:	b0 de       	rcall	.-672    	; 0x113c <make_tcphead>
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + 4 (one option: mss)
        ck=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+4,2);
    13dc:	c8 01       	movw	r24, r16
    13de:	4a 96       	adiw	r24, 0x1a	; 26
    13e0:	60 e2       	ldi	r22, 0x20	; 32
    13e2:	70 e0       	ldi	r23, 0x00	; 0
    13e4:	42 e0       	ldi	r20, 0x02	; 2
    13e6:	68 dd       	rcall	.-1328   	; 0xeb8 <checksum>
        buf[TCP_CHECKSUM_H_P]=ck>>8;
    13e8:	f8 01       	movw	r30, r16
    13ea:	92 ab       	std	Z+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=ck& 0xff;
    13ec:	83 ab       	std	Z+51, r24	; 0x33
        // add 4 for option mss:
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN,buf);
    13ee:	8a e3       	ldi	r24, 0x3A	; 58
    13f0:	90 e0       	ldi	r25, 0x00	; 0
    13f2:	b8 01       	movw	r22, r16
    13f4:	5e d2       	rcall	.+1212   	; 0x18b2 <enc28j60PacketSend>
}
    13f6:	1f 91       	pop	r17
    13f8:	0f 91       	pop	r16
    13fa:	08 95       	ret

000013fc <make_udp_reply_from_request>:
        enc28j60PacketSend(len,buf);
}

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
    13fc:	df 92       	push	r13
    13fe:	ef 92       	push	r14
    1400:	ff 92       	push	r15
    1402:	0f 93       	push	r16
    1404:	1f 93       	push	r17
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	ec 01       	movw	r28, r24
    140c:	7b 01       	movw	r14, r22
    140e:	14 2f       	mov	r17, r20
    1410:	d2 2e       	mov	r13, r18
    1412:	03 2f       	mov	r16, r19
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
    1414:	40 de       	rcall	.-896    	; 0x1096 <make_eth>
    1416:	1d 3d       	cpi	r17, 0xDD	; 221
    1418:	08 f0       	brcs	.+2      	; 0x141c <make_udp_reply_from_request+0x20>
    141a:	1c ed       	ldi	r17, 0xDC	; 220
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    141c:	18 8a       	std	Y+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    141e:	14 5e       	subi	r17, 0xE4	; 228
    1420:	19 8b       	std	Y+17, r17	; 0x11
        make_ip(buf);
    1422:	ce 01       	movw	r24, r28
    1424:	7b de       	rcall	.-778    	; 0x111c <make_ip>
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
    1426:	8a a1       	ldd	r24, Y+34	; 0x22
    1428:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
    142a:	8b a1       	ldd	r24, Y+35	; 0x23
    142c:	8d a3       	std	Y+37, r24	; 0x25
        buf[UDP_SRC_PORT_H_P]=port>>8;
    142e:	0a a3       	std	Y+34, r16	; 0x22
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
    1430:	db a2       	std	Y+35, r13	; 0x23
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
    1432:	1e a2       	std	Y+38, r1	; 0x26
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    1434:	14 51       	subi	r17, 0x14	; 20
    1436:	1f a3       	std	Y+39, r17	; 0x27
    1438:	18 50       	subi	r17, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    143a:	18 a6       	std	Y+40, r1	; 0x28
        buf[UDP_CHECKSUM_L_P]=0;
    143c:	19 a6       	std	Y+41, r1	; 0x29
    143e:	de 01       	movw	r26, r28
    1440:	9a 96       	adiw	r26, 0x2a	; 42
    1442:	20 e0       	ldi	r18, 0x00	; 0
    1444:	30 e0       	ldi	r19, 0x00	; 0
    1446:	07 c0       	rjmp	.+14     	; 0x1456 <make_udp_reply_from_request+0x5a>
        // copy the data:
        while(i<datalen){
                buf[UDP_DATA_P+i]=data[i];
    1448:	f7 01       	movw	r30, r14
    144a:	e2 0f       	add	r30, r18
    144c:	f3 1f       	adc	r31, r19
    144e:	80 81       	ld	r24, Z
    1450:	8d 93       	st	X+, r24
    1452:	2f 5f       	subi	r18, 0xFF	; 255
    1454:	3f 4f       	sbci	r19, 0xFF	; 255
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
    1456:	21 17       	cp	r18, r17
    1458:	b8 f3       	brcs	.-18     	; 0x1448 <make_udp_reply_from_request+0x4c>
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    145a:	01 2f       	mov	r16, r17
    145c:	10 e0       	ldi	r17, 0x00	; 0
    145e:	00 5f       	subi	r16, 0xF0	; 240
    1460:	1f 4f       	sbci	r17, 0xFF	; 255
    1462:	ce 01       	movw	r24, r28
    1464:	4a 96       	adiw	r24, 0x1a	; 26
    1466:	b8 01       	movw	r22, r16
    1468:	41 e0       	ldi	r20, 0x01	; 1
    146a:	26 dd       	rcall	.-1460   	; 0xeb8 <checksum>
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    146c:	98 a7       	std	Y+40, r25	; 0x28
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
    146e:	89 a7       	std	Y+41, r24	; 0x29
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    1470:	c8 01       	movw	r24, r16
    1472:	4a 96       	adiw	r24, 0x1a	; 26
    1474:	be 01       	movw	r22, r28
    1476:	1d d2       	rcall	.+1082   	; 0x18b2 <enc28j60PacketSend>
}
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	ff 90       	pop	r15
    1482:	ef 90       	pop	r14
    1484:	df 90       	pop	r13
    1486:	08 95       	ret

00001488 <make_echo_reply_from_request>:
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
}

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    1488:	0f 93       	push	r16
    148a:	1f 93       	push	r17
    148c:	cf 93       	push	r28
    148e:	df 93       	push	r29
    1490:	ec 01       	movw	r28, r24
    1492:	8b 01       	movw	r16, r22
        make_eth(buf);
    1494:	00 de       	rcall	.-1024   	; 0x1096 <make_eth>
        make_ip(buf);
    1496:	ce 01       	movw	r24, r28
    1498:	41 de       	rcall	.-894    	; 0x111c <make_ip>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    149a:	1a a2       	std	Y+34, r1	; 0x22
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    149c:	8c a1       	ldd	r24, Y+36	; 0x24
    149e:	88 3f       	cpi	r24, 0xF8	; 248
    14a0:	18 f0       	brcs	.+6      	; 0x14a8 <make_echo_reply_from_request+0x20>
                buf[ICMP_CHECKSUM_P+1]++;
    14a2:	8d a1       	ldd	r24, Y+37	; 0x25
    14a4:	8f 5f       	subi	r24, 0xFF	; 255
    14a6:	8d a3       	std	Y+37, r24	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    14a8:	8c a1       	ldd	r24, Y+36	; 0x24
    14aa:	88 5f       	subi	r24, 0xF8	; 248
    14ac:	8c a3       	std	Y+36, r24	; 0x24
        //
        enc28j60PacketSend(len,buf);
    14ae:	c8 01       	movw	r24, r16
    14b0:	be 01       	movw	r22, r28
    14b2:	ff d1       	rcall	.+1022   	; 0x18b2 <enc28j60PacketSend>
}
    14b4:	df 91       	pop	r29
    14b6:	cf 91       	pop	r28
    14b8:	1f 91       	pop	r17
    14ba:	0f 91       	pop	r16
    14bc:	08 95       	ret

000014be <make_arp_answer_from_request>:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}

void make_arp_answer_from_request(uint8_t *buf)
{
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	ec 01       	movw	r28, r24
        uint8_t i=0;
        //
        make_eth(buf);
    14c4:	e8 dd       	rcall	.-1072   	; 0x1096 <make_eth>
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    14c6:	1c 8a       	std	Y+20, r1	; 0x14
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    14c8:	82 e0       	ldi	r24, 0x02	; 2
    14ca:	8d 8b       	std	Y+21, r24	; 0x15
    14cc:	fe 01       	movw	r30, r28
    14ce:	a6 e0       	ldi	r26, 0x06	; 6
    14d0:	b3 e0       	ldi	r27, 0x03	; 3
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_SRC_MAC +i];// macaddr_gw[i];//buf[ETH_ARP_SRC_MAC_P+i];
    14d2:	86 81       	ldd	r24, Z+6	; 0x06
    14d4:	80 a3       	std	Z+32, r24	; 0x20
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    14d6:	8d 91       	ld	r24, X+
    14d8:	86 8b       	std	Z+22, r24	; 0x16
    14da:	31 96       	adiw	r30, 0x01	; 1
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    14dc:	83 e0       	ldi	r24, 0x03	; 3
    14de:	ac 30       	cpi	r26, 0x0C	; 12
    14e0:	b8 07       	cpc	r27, r24
    14e2:	b9 f7       	brne	.-18     	; 0x14d2 <make_arp_answer_from_request+0x14>
    14e4:	fe 01       	movw	r30, r28
    14e6:	7c 96       	adiw	r30, 0x1c	; 28
    14e8:	ac e0       	ldi	r26, 0x0C	; 12
    14ea:	b3 e0       	ldi	r27, 0x03	; 3
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    14ec:	80 81       	ld	r24, Z
    14ee:	82 87       	std	Z+10, r24	; 0x0a
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    14f0:	8d 91       	ld	r24, X+
    14f2:	81 93       	st	Z+, r24
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_SRC_MAC +i];// macaddr_gw[i];//buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    14f4:	83 e0       	ldi	r24, 0x03	; 3
    14f6:	a0 31       	cpi	r26, 0x10	; 16
    14f8:	b8 07       	cpc	r27, r24
    14fa:	c1 f7       	brne	.-16     	; 0x14ec <make_arp_answer_from_request+0x2e>
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    14fc:	8a e2       	ldi	r24, 0x2A	; 42
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	be 01       	movw	r22, r28
    1502:	d7 d1       	rcall	.+942    	; 0x18b2 <enc28j60PacketSend>
}
    1504:	df 91       	pop	r29
    1506:	cf 91       	pop	r28
    1508:	08 95       	ret

0000150a <ow_reset>:
 * Формируем 1-Wire reset, возвращаем 0 если presense не обнаружен,
 * возвращаем 1 если presense обнаружен.
 */
 
uint8_t ow_reset(void) {
  cli();
    150a:	f8 94       	cli
	uint8_t result = 1;
	OW_PORT &= ~(1 << OW_P);	// 0 в порт для "просадки" в ноль
    150c:	aa 98       	cbi	0x15, 2	; 21
	wire_0;						// включаем "просадку"
    150e:	a2 9a       	sbi	0x14, 2	; 20
    1510:	8c ed       	ldi	r24, 0xDC	; 220
    1512:	95 e0       	ldi	r25, 0x05	; 5
    1514:	01 97       	sbiw	r24, 0x01	; 1
    1516:	f1 f7       	brne	.-4      	; 0x1514 <ow_reset+0xa>
    _delay_us(500);				// RESET Pulse
	wire_1;						// отключаем просадку
    1518:	a2 98       	cbi	0x14, 2	; 20
    151a:	8c e2       	ldi	r24, 0x2C	; 44
    151c:	91 e0       	ldi	r25, 0x01	; 1
    151e:	01 97       	sbiw	r24, 0x01	; 1
    1520:	f1 f7       	brne	.-4      	; 0x151e <ow_reset+0x14>
	_delay_us(100);
	if (OW_PIN & (1 << OW_P)) result = 0;
    1522:	83 b3       	in	r24, 0x13	; 19
    1524:	e0 eb       	ldi	r30, 0xB0	; 176
    1526:	f4 e0       	ldi	r31, 0x04	; 4
    1528:	31 97       	sbiw	r30, 0x01	; 1
    152a:	f1 f7       	brne	.-4      	; 0x1528 <ow_reset+0x1e>
	_delay_us(400);				// защитная пауза в конце
	sei();
    152c:	78 94       	sei
    152e:	86 95       	lsr	r24
    1530:	86 95       	lsr	r24
    1532:	80 95       	com	r24
	return result;
} 
    1534:	81 70       	andi	r24, 0x01	; 1
    1536:	08 95       	ret

00001538 <ow_put_bit>:
/*-----------------------------------------------------------------------------
 передача бита на шину 
 */
void ow_put_bit(uint8_t bit){
  cli();
    1538:	f8 94       	cli
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    153a:	98 e2       	ldi	r25, 0x28	; 40
    153c:	9a 95       	dec	r25
    153e:	f1 f7       	brne	.-4      	; 0x153c <ow_put_bit+0x4>
    ow_delay;			         // ???
    cli ();                     // запрещаем прерывания
    1540:	f8 94       	cli
	wire_0;                    // порт на выход
    1542:	a2 9a       	sbi	0x14, 2	; 20
    1544:	98 e1       	ldi	r25, 0x18	; 24
    1546:	9a 95       	dec	r25
    1548:	f1 f7       	brne	.-4      	; 0x1546 <ow_put_bit+0xe>
	_delay_us(6);	           // начало тайм-слота
	sei();
    154a:	78 94       	sei
    if (bit){ 
    154c:	88 23       	and	r24, r24
    154e:	31 f0       	breq	.+12     	; 0x155c <ow_put_bit+0x24>
		wire_1;               
    1550:	a2 98       	cbi	0x14, 2	; 20
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1552:	8e e0       	ldi	r24, 0x0E	; 14
    1554:	91 e0       	ldi	r25, 0x01	; 1
    1556:	01 97       	sbiw	r24, 0x01	; 1
    1558:	f1 f7       	brne	.-4      	; 0x1556 <ow_put_bit+0x1e>
    155a:	05 c0       	rjmp	.+10     	; 0x1566 <ow_put_bit+0x2e>
		_delay_us(90);
    } else {
		_delay_us(90);
		wire_1;          
    155c:	8e e0       	ldi	r24, 0x0E	; 14
    155e:	91 e0       	ldi	r25, 0x01	; 1
    1560:	01 97       	sbiw	r24, 0x01	; 1
    1562:	f1 f7       	brne	.-4      	; 0x1560 <ow_put_bit+0x28>
    1564:	a2 98       	cbi	0x14, 2	; 20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1566:	88 e2       	ldi	r24, 0x28	; 40
    1568:	8a 95       	dec	r24
    156a:	f1 f7       	brne	.-4      	; 0x1568 <ow_put_bit+0x30>
	}
	ow_delay;			// ???
	sei();
    156c:	78 94       	sei
}
    156e:	08 95       	ret

00001570 <ow_get_bit>:

/*-----------------------------------------------------------------------------
 *  принимаем бит с шины
 */
uint8_t ow_get_bit(void) {
  cli();
    1570:	f8 94       	cli
    1572:	88 e2       	ldi	r24, 0x28	; 40
    1574:	8a 95       	dec	r24
    1576:	f1 f7       	brne	.-4      	; 0x1574 <ow_get_bit+0x4>
    uint8_t result;
	ow_delay;			// ???
	cli();
    1578:	f8 94       	cli
	wire_0;
    157a:	a2 9a       	sbi	0x14, 2	; 20
    157c:	88 e1       	ldi	r24, 0x18	; 24
    157e:	8a 95       	dec	r24
    1580:	f1 f7       	brne	.-4      	; 0x157e <ow_get_bit+0xe>
	_delay_us(6);		// начало тайм-слота
	wire_1;
    1582:	a2 98       	cbi	0x14, 2	; 20
    1584:	8c e1       	ldi	r24, 0x1C	; 28
    1586:	8a 95       	dec	r24
    1588:	f1 f7       	brne	.-4      	; 0x1586 <ow_get_bit+0x16>
	_delay_us(7);		// опрос на 14-й микросекунде
	result = (OW_PIN >> OW_P) & 1; // ринятое в result
    158a:	83 b3       	in	r24, 0x13	; 19
	sei();
    158c:	78 94       	sei
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    158e:	ee e0       	ldi	r30, 0x0E	; 14
    1590:	f1 e0       	ldi	r31, 0x01	; 1
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	f1 f7       	brne	.-4      	; 0x1592 <ow_get_bit+0x22>

	_delay_us(90);
	sei();
    1596:	78 94       	sei
    1598:	86 95       	lsr	r24
    159a:	86 95       	lsr	r24
    return result;     // возвращаем значение 
}
    159c:	81 70       	andi	r24, 0x01	; 1
    159e:	08 95       	ret

000015a0 <ow_write_byte>:

/*-----------------------------------------------------------------------------
 передаем байты датчику (используем функцию ow_put_bit)
 */
void ow_write_byte(uint8_t data) {
    15a0:	0f 93       	push	r16
    15a2:	1f 93       	push	r17
    15a4:	08 2f       	mov	r16, r24
  cli();
    15a6:	f8 94       	cli
    15a8:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t i;
 for (i = 0; i < 8; i++) {                 // цикл передачи байтов
		ow_put_bit(data & 0x01);           // передача бита в порт
    15aa:	80 2f       	mov	r24, r16
    15ac:	81 70       	andi	r24, 0x01	; 1
    15ae:	c4 df       	rcall	.-120    	; 0x1538 <ow_put_bit>
		data >>= 1;                        // следующий бит
    15b0:	06 95       	lsr	r16
 передаем байты датчику (используем функцию ow_put_bit)
 */
void ow_write_byte(uint8_t data) {
  cli();
    uint8_t i;
 for (i = 0; i < 8; i++) {                 // цикл передачи байтов
    15b2:	1f 5f       	subi	r17, 0xFF	; 255
    15b4:	18 30       	cpi	r17, 0x08	; 8
    15b6:	c9 f7       	brne	.-14     	; 0x15aa <ow_write_byte+0xa>
		ow_put_bit(data & 0x01);           // передача бита в порт
		data >>= 1;                        // следующий бит
    }
	sei();
    15b8:	78 94       	sei
}
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	08 95       	ret

000015c0 <ow_read_byte>:

  /*-----------------------------------------------------------------------------
 *  чтение данных датчика возвращает прочитанный байт 
 */
uint8_t ow_read_byte(void) {
    15c0:	0f 93       	push	r16
    15c2:	1f 93       	push	r17
  cli();
    15c4:	f8 94       	cli
    15c6:	00 e0       	ldi	r16, 0x00	; 0
    15c8:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t i, result = 0;

    for (i = 0; i < 8; i++) {         // ОРГАНИЗУЕМ ЦИКЛ
		result >>= 1;
	    result |= ow_get_bit()<<7;    // заполняем данными 
    15ca:	d2 df       	rcall	.-92     	; 0x1570 <ow_get_bit>
    15cc:	91 2f       	mov	r25, r17
    15ce:	96 95       	lsr	r25
    15d0:	18 2f       	mov	r17, r24
    15d2:	17 95       	ror	r17
    15d4:	11 27       	eor	r17, r17
    15d6:	17 95       	ror	r17
    15d8:	19 2b       	or	r17, r25
 */
uint8_t ow_read_byte(void) {
  cli();
    uint8_t i, result = 0;

    for (i = 0; i < 8; i++) {         // ОРГАНИЗУЕМ ЦИКЛ
    15da:	0f 5f       	subi	r16, 0xFF	; 255
    15dc:	08 30       	cpi	r16, 0x08	; 8
    15de:	a9 f7       	brne	.-22     	; 0x15ca <ow_read_byte+0xa>
		result >>= 1;
	    result |= ow_get_bit()<<7;    // заполняем данными 
    }
	sei();
    15e0:	78 94       	sei
    return result;    
}
    15e2:	81 2f       	mov	r24, r17
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	08 95       	ret

000015ea <enc28j60ReadOp>:
//
#define waitspi() while(!(SPSR&(1<<SPIF)))        

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
        CSACTIVE;
    15ea:	c1 98       	cbi	0x18, 1	; 24
        // issue read command
        SPDR = op | (address & ADDR_MASK);
    15ec:	96 2f       	mov	r25, r22
    15ee:	9f 71       	andi	r25, 0x1F	; 31
    15f0:	98 2b       	or	r25, r24
    15f2:	9f b9       	out	0x0f, r25	; 15
        waitspi();
    15f4:	77 9b       	sbis	0x0e, 7	; 14
    15f6:	fe cf       	rjmp	.-4      	; 0x15f4 <enc28j60ReadOp+0xa>
        // read data
        SPDR = 0x00;
    15f8:	1f b8       	out	0x0f, r1	; 15
        waitspi();
    15fa:	77 9b       	sbis	0x0e, 7	; 14
    15fc:	fe cf       	rjmp	.-4      	; 0x15fa <enc28j60ReadOp+0x10>
        // do dummy read if needed (for mac and mii, see datasheet page 29)
        if(address & 0x80)
    15fe:	67 ff       	sbrs	r22, 7
    1600:	03 c0       	rjmp	.+6      	; 0x1608 <enc28j60ReadOp+0x1e>
        {
                SPDR = 0x00;
    1602:	1f b8       	out	0x0f, r1	; 15
                waitspi();
    1604:	77 9b       	sbis	0x0e, 7	; 14
    1606:	fe cf       	rjmp	.-4      	; 0x1604 <enc28j60ReadOp+0x1a>
        }
        // release CS
        CSPASSIVE;
    1608:	c1 9a       	sbi	0x18, 1	; 24
        return(SPDR);
    160a:	8f b1       	in	r24, 0x0f	; 15
}
    160c:	08 95       	ret

0000160e <enc28j60WriteOp>:

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    160e:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    1610:	6f 71       	andi	r22, 0x1F	; 31
    1612:	68 2b       	or	r22, r24
    1614:	6f b9       	out	0x0f, r22	; 15
        waitspi();
    1616:	77 9b       	sbis	0x0e, 7	; 14
    1618:	fe cf       	rjmp	.-4      	; 0x1616 <enc28j60WriteOp+0x8>
        // write data
        SPDR = data;
    161a:	4f b9       	out	0x0f, r20	; 15
        waitspi();
    161c:	77 9b       	sbis	0x0e, 7	; 14
    161e:	fe cf       	rjmp	.-4      	; 0x161c <enc28j60WriteOp+0xe>
        CSPASSIVE;
    1620:	c1 9a       	sbi	0x18, 1	; 24
}
    1622:	08 95       	ret

00001624 <enc28j60ReadBuffer>:

void enc28j60ReadBuffer(uint16_t len, uint8_t* data)
{
    1624:	ac 01       	movw	r20, r24
    1626:	fb 01       	movw	r30, r22
        CSACTIVE;
    1628:	c1 98       	cbi	0x18, 1	; 24
        // issue read command
        SPDR = ENC28J60_READ_BUF_MEM;
    162a:	8a e3       	ldi	r24, 0x3A	; 58
    162c:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    162e:	77 9b       	sbis	0x0e, 7	; 14
    1630:	fe cf       	rjmp	.-4      	; 0x162e <enc28j60ReadBuffer+0xa>
    1632:	9a 01       	movw	r18, r20
    1634:	df 01       	movw	r26, r30
    1636:	07 c0       	rjmp	.+14     	; 0x1646 <enc28j60ReadBuffer+0x22>
        while(len)
        {
                len--;
                // read data
                SPDR = 0x00;
    1638:	1f b8       	out	0x0f, r1	; 15
                waitspi();
    163a:	77 9b       	sbis	0x0e, 7	; 14
    163c:	fe cf       	rjmp	.-4      	; 0x163a <enc28j60ReadBuffer+0x16>
        // issue read command
        SPDR = ENC28J60_READ_BUF_MEM;
        waitspi();
        while(len)
        {
                len--;
    163e:	21 50       	subi	r18, 0x01	; 1
    1640:	30 40       	sbci	r19, 0x00	; 0
                // read data
                SPDR = 0x00;
                waitspi();
                *data = SPDR;
    1642:	8f b1       	in	r24, 0x0f	; 15
    1644:	8d 93       	st	X+, r24
{
        CSACTIVE;
        // issue read command
        SPDR = ENC28J60_READ_BUF_MEM;
        waitspi();
        while(len)
    1646:	21 15       	cp	r18, r1
    1648:	31 05       	cpc	r19, r1
    164a:	b1 f7       	brne	.-20     	; 0x1638 <enc28j60ReadBuffer+0x14>
                SPDR = 0x00;
                waitspi();
                *data = SPDR;
                data++;
        }
        *data='\0';
    164c:	e4 0f       	add	r30, r20
    164e:	f5 1f       	adc	r31, r21
    1650:	10 82       	st	Z, r1
        CSPASSIVE;
    1652:	c1 9a       	sbi	0x18, 1	; 24
}
    1654:	08 95       	ret

00001656 <enc28j60WriteBuffer>:

void enc28j60WriteBuffer(uint16_t len, uint8_t* data)
{
    1656:	9c 01       	movw	r18, r24
    1658:	fb 01       	movw	r30, r22
        CSACTIVE;
    165a:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
    165c:	8a e7       	ldi	r24, 0x7A	; 122
    165e:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1660:	77 9b       	sbis	0x0e, 7	; 14
    1662:	fe cf       	rjmp	.-4      	; 0x1660 <enc28j60WriteBuffer+0xa>
    1664:	07 c0       	rjmp	.+14     	; 0x1674 <enc28j60WriteBuffer+0x1e>
        while(len)
        {
                len--;
                // write data
                SPDR = *data;
    1666:	80 81       	ld	r24, Z
    1668:	8f b9       	out	0x0f, r24	; 15
                data++;
                waitspi();
    166a:	77 9b       	sbis	0x0e, 7	; 14
    166c:	fe cf       	rjmp	.-4      	; 0x166a <enc28j60WriteBuffer+0x14>
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
        {
                len--;
    166e:	21 50       	subi	r18, 0x01	; 1
    1670:	30 40       	sbci	r19, 0x00	; 0
                // write data
                SPDR = *data;
                data++;
    1672:	31 96       	adiw	r30, 0x01	; 1
{
        CSACTIVE;
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
    1674:	21 15       	cp	r18, r1
    1676:	31 05       	cpc	r19, r1
    1678:	b1 f7       	brne	.-20     	; 0x1666 <enc28j60WriteBuffer+0x10>
                // write data
                SPDR = *data;
                data++;
                waitspi();
        }
        CSPASSIVE;
    167a:	c1 9a       	sbi	0x18, 1	; 24
}
    167c:	08 95       	ret

0000167e <enc28j60SetBank>:

void enc28j60SetBank(uint8_t address)
{
    167e:	48 2f       	mov	r20, r24
        // set the bank (if needed)
        if((address & BANK_MASK) != Enc28j60Bank)
    1680:	28 2f       	mov	r18, r24
    1682:	30 e0       	ldi	r19, 0x00	; 0
    1684:	20 76       	andi	r18, 0x60	; 96
    1686:	30 70       	andi	r19, 0x00	; 0
    1688:	80 91 16 03 	lds	r24, 0x0316
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	28 17       	cp	r18, r24
    1690:	39 07       	cpc	r19, r25
    1692:	d9 f0       	breq	.+54     	; 0x16ca <enc28j60SetBank+0x4c>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    1694:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    1696:	8f eb       	ldi	r24, 0xBF	; 191
    1698:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    169a:	77 9b       	sbis	0x0e, 7	; 14
    169c:	fe cf       	rjmp	.-4      	; 0x169a <enc28j60SetBank+0x1c>
        // write data
        SPDR = data;
    169e:	83 e0       	ldi	r24, 0x03	; 3
    16a0:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    16a2:	77 9b       	sbis	0x0e, 7	; 14
    16a4:	fe cf       	rjmp	.-4      	; 0x16a2 <enc28j60SetBank+0x24>
        CSPASSIVE;
    16a6:	c1 9a       	sbi	0x18, 1	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    16a8:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    16aa:	8f e9       	ldi	r24, 0x9F	; 159
    16ac:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    16ae:	77 9b       	sbis	0x0e, 7	; 14
    16b0:	fe cf       	rjmp	.-4      	; 0x16ae <enc28j60SetBank+0x30>
        // set the bank (if needed)
        if((address & BANK_MASK) != Enc28j60Bank)
        {
                // set the bank
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
                enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    16b2:	85 e0       	ldi	r24, 0x05	; 5
    16b4:	35 95       	asr	r19
    16b6:	27 95       	ror	r18
    16b8:	8a 95       	dec	r24
    16ba:	e1 f7       	brne	.-8      	; 0x16b4 <enc28j60SetBank+0x36>
        CSACTIVE;
        // issue write command
        SPDR = op | (address & ADDR_MASK);
        waitspi();
        // write data
        SPDR = data;
    16bc:	2f b9       	out	0x0f, r18	; 15
        waitspi();
    16be:	77 9b       	sbis	0x0e, 7	; 14
    16c0:	fe cf       	rjmp	.-4      	; 0x16be <enc28j60SetBank+0x40>
        CSPASSIVE;
    16c2:	c1 9a       	sbi	0x18, 1	; 24
        if((address & BANK_MASK) != Enc28j60Bank)
        {
                // set the bank
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
                enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
                Enc28j60Bank = (address & BANK_MASK);
    16c4:	40 76       	andi	r20, 0x60	; 96
    16c6:	40 93 16 03 	sts	0x0316, r20
    16ca:	08 95       	ret

000016cc <enc28j60Read>:
        }
}

uint8_t enc28j60Read(uint8_t address)
{
    16cc:	1f 93       	push	r17
    16ce:	18 2f       	mov	r17, r24
        // set the bank
        enc28j60SetBank(address);
    16d0:	d6 df       	rcall	.-84     	; 0x167e <enc28j60SetBank>
        // do the read
        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    16d2:	80 e0       	ldi	r24, 0x00	; 0
    16d4:	61 2f       	mov	r22, r17
    16d6:	89 df       	rcall	.-238    	; 0x15ea <enc28j60ReadOp>
}
    16d8:	1f 91       	pop	r17
    16da:	08 95       	ret

000016dc <enc28j60Write>:
	
	return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    16dc:	0f 93       	push	r16
    16de:	1f 93       	push	r17
    16e0:	18 2f       	mov	r17, r24
    16e2:	06 2f       	mov	r16, r22
        // set the bank
        enc28j60SetBank(address);
    16e4:	cc df       	rcall	.-104    	; 0x167e <enc28j60SetBank>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    16e6:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    16e8:	1f 71       	andi	r17, 0x1F	; 31
    16ea:	10 64       	ori	r17, 0x40	; 64
    16ec:	1f b9       	out	0x0f, r17	; 15
        waitspi();
    16ee:	77 9b       	sbis	0x0e, 7	; 14
    16f0:	fe cf       	rjmp	.-4      	; 0x16ee <enc28j60Write+0x12>
        // write data
        SPDR = data;
    16f2:	0f b9       	out	0x0f, r16	; 15
        waitspi();
    16f4:	77 9b       	sbis	0x0e, 7	; 14
    16f6:	fe cf       	rjmp	.-4      	; 0x16f4 <enc28j60Write+0x18>
        CSPASSIVE;
    16f8:	c1 9a       	sbi	0x18, 1	; 24
{
        // set the bank
        enc28j60SetBank(address);
        // do the write
        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}
    16fa:	1f 91       	pop	r17
    16fc:	0f 91       	pop	r16
    16fe:	08 95       	ret

00001700 <enc28j60PhyReadH>:
        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
}

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
    1700:	68 2f       	mov	r22, r24

	// Set the right address and start the register read operation
	enc28j60Write(MIREGADR, address);
    1702:	84 ed       	ldi	r24, 0xD4	; 212
    1704:	eb df       	rcall	.-42     	; 0x16dc <enc28j60Write>
	enc28j60Write(MICMD, MICMD_MIIRD);
    1706:	82 ed       	ldi	r24, 0xD2	; 210
    1708:	61 e0       	ldi	r22, 0x01	; 1
    170a:	e8 df       	rcall	.-48     	; 0x16dc <enc28j60Write>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    170c:	8c e3       	ldi	r24, 0x3C	; 60
    170e:	8a 95       	dec	r24
    1710:	f1 f7       	brne	.-4      	; 0x170e <enc28j60PhyReadH+0xe>
        _delay_us(15);

	// wait until the PHY read completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
    1712:	8a ee       	ldi	r24, 0xEA	; 234
    1714:	db df       	rcall	.-74     	; 0x16cc <enc28j60Read>
    1716:	80 fd       	sbrc	r24, 0
    1718:	fc cf       	rjmp	.-8      	; 0x1712 <enc28j60PhyReadH+0x12>

	// reset reading bit
	enc28j60Write(MICMD, 0x00);
    171a:	82 ed       	ldi	r24, 0xD2	; 210
    171c:	60 e0       	ldi	r22, 0x00	; 0
    171e:	de df       	rcall	.-68     	; 0x16dc <enc28j60Write>
	
	return (enc28j60Read(MIRDH));
    1720:	89 ed       	ldi	r24, 0xD9	; 217
    1722:	d4 df       	rcall	.-88     	; 0x16cc <enc28j60Read>
}
    1724:	90 e0       	ldi	r25, 0x00	; 0
    1726:	08 95       	ret

00001728 <enc28j60PhyWrite>:
        // do the write
        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    1728:	0f 93       	push	r16
    172a:	1f 93       	push	r17
    172c:	98 2f       	mov	r25, r24
    172e:	16 2f       	mov	r17, r22
    1730:	07 2f       	mov	r16, r23
        // set the PHY register address
        enc28j60Write(MIREGADR, address);
    1732:	84 ed       	ldi	r24, 0xD4	; 212
    1734:	69 2f       	mov	r22, r25
    1736:	d2 df       	rcall	.-92     	; 0x16dc <enc28j60Write>
        // write the PHY data
        enc28j60Write(MIWRL, data);
    1738:	86 ed       	ldi	r24, 0xD6	; 214
    173a:	61 2f       	mov	r22, r17
    173c:	cf df       	rcall	.-98     	; 0x16dc <enc28j60Write>
        enc28j60Write(MIWRH, data>>8);
    173e:	87 ed       	ldi	r24, 0xD7	; 215
    1740:	60 2f       	mov	r22, r16
    1742:	cc df       	rcall	.-104    	; 0x16dc <enc28j60Write>
    1744:	1c e3       	ldi	r17, 0x3C	; 60
    1746:	03 c0       	rjmp	.+6      	; 0x174e <enc28j60PhyWrite+0x26>
    1748:	81 2f       	mov	r24, r17
    174a:	8a 95       	dec	r24
    174c:	f1 f7       	brne	.-4      	; 0x174a <enc28j60PhyWrite+0x22>
        // wait until the PHY write completes
        while(enc28j60Read(MISTAT) & MISTAT_BUSY){
    174e:	8a ee       	ldi	r24, 0xEA	; 234
    1750:	bd df       	rcall	.-134    	; 0x16cc <enc28j60Read>
    1752:	80 fd       	sbrc	r24, 0
    1754:	f9 cf       	rjmp	.-14     	; 0x1748 <enc28j60PhyWrite+0x20>
                _delay_us(15);
        }
}
    1756:	1f 91       	pop	r17
    1758:	0f 91       	pop	r16
    175a:	08 95       	ret

0000175c <enc28j60clkout>:

void enc28j60clkout(uint8_t clk)
{
        //setup clkout: 2 is 12.5MHz:
	enc28j60Write(ECOCON, clk & 0x7);
    175c:	68 2f       	mov	r22, r24
    175e:	67 70       	andi	r22, 0x07	; 7
    1760:	85 e7       	ldi	r24, 0x75	; 117
    1762:	bc df       	rcall	.-136    	; 0x16dc <enc28j60Write>
}
    1764:	08 95       	ret

00001766 <enc28j60Init>:

void enc28j60Init(uint8_t* macaddr)
{
    1766:	cf 93       	push	r28
    1768:	df 93       	push	r29
    176a:	ec 01       	movw	r28, r24
	// initialize I/O
        // ss as output:
	ENC28J60_CONTROL_DDR |= 1<<ENC28J60_CONTROL_CS;
    176c:	b9 9a       	sbi	0x17, 1	; 23
	CSPASSIVE; // ss=0
    176e:	c1 9a       	sbi	0x18, 1	; 24
        //	
	ENC28J60_CONTROL_DDR  |= 1<<ENC28J60_CONTROL_SI | 1<<ENC28J60_CONTROL_SCK|0<< ENC28J60_CONTROL_SS; // mosi, sck output
    1770:	87 b3       	in	r24, 0x17	; 23
    1772:	88 62       	ori	r24, 0x28	; 40
    1774:	87 bb       	out	0x17, r24	; 23
	cbi(ENC28J60_CONTROL_DDR,ENC28J60_CONTROL_SO); // MISO is input
    1776:	bc 98       	cbi	0x17, 4	; 23
        //
        cbi(ENC28J60_CONTROL_PORT,ENC28J60_CONTROL_SI); // MOSI low
    1778:	c3 98       	cbi	0x18, 3	; 24
        cbi(ENC28J60_CONTROL_PORT,ENC28J60_CONTROL_SCK); // SCK low
    177a:	c5 98       	cbi	0x18, 5	; 24
	    sbi(ENC28J60_CONTROL_PORT,ENC28J60_CONTROL_SS);
    177c:	c2 9a       	sbi	0x18, 2	; 24
	//
	// initialize SPI interface
	// master mode and Fosc/2 clock:
        SPCR = (1<<SPE)|(1<<MSTR);
    177e:	80 e5       	ldi	r24, 0x50	; 80
    1780:	8d b9       	out	0x0d, r24	; 13
        SPSR |= (1<<SPI2X);
    1782:	70 9a       	sbi	0x0e, 0	; 14
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    1784:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    1786:	8f ef       	ldi	r24, 0xFF	; 255
    1788:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    178a:	77 9b       	sbis	0x0e, 7	; 14
    178c:	fe cf       	rjmp	.-4      	; 0x178a <enc28j60Init+0x24>
        // write data
        SPDR = data;
    178e:	8f ef       	ldi	r24, 0xFF	; 255
    1790:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1792:	77 9b       	sbis	0x0e, 7	; 14
    1794:	fe cf       	rjmp	.-4      	; 0x1792 <enc28j60Init+0x2c>
        CSPASSIVE;
    1796:	c1 9a       	sbi	0x18, 1	; 24
    1798:	8d ec       	ldi	r24, 0xCD	; 205
    179a:	8a 95       	dec	r24
    179c:	f1 f7       	brne	.-4      	; 0x179a <enc28j60Init+0x34>
	//while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	gNextPacketPtr = RXSTART_INIT;
    179e:	10 92 18 03 	sts	0x0318, r1
    17a2:	10 92 17 03 	sts	0x0317, r1
        // Rx start
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
    17a6:	88 e0       	ldi	r24, 0x08	; 8
    17a8:	60 e0       	ldi	r22, 0x00	; 0
    17aa:	98 df       	rcall	.-208    	; 0x16dc <enc28j60Write>
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
    17ac:	89 e0       	ldi	r24, 0x09	; 9
    17ae:	60 e0       	ldi	r22, 0x00	; 0
    17b0:	95 df       	rcall	.-214    	; 0x16dc <enc28j60Write>
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
    17b2:	8c e0       	ldi	r24, 0x0C	; 12
    17b4:	60 e0       	ldi	r22, 0x00	; 0
    17b6:	92 df       	rcall	.-220    	; 0x16dc <enc28j60Write>
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
    17b8:	8d e0       	ldi	r24, 0x0D	; 13
    17ba:	60 e0       	ldi	r22, 0x00	; 0
    17bc:	8f df       	rcall	.-226    	; 0x16dc <enc28j60Write>
	// RX end
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
    17be:	8a e0       	ldi	r24, 0x0A	; 10
    17c0:	6e ef       	ldi	r22, 0xFE	; 254
    17c2:	8c df       	rcall	.-232    	; 0x16dc <enc28j60Write>
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
    17c4:	8b e0       	ldi	r24, 0x0B	; 11
    17c6:	69 e1       	ldi	r22, 0x19	; 25
    17c8:	89 df       	rcall	.-238    	; 0x16dc <enc28j60Write>
	// TX start
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
    17ca:	84 e0       	ldi	r24, 0x04	; 4
    17cc:	6f ef       	ldi	r22, 0xFF	; 255
    17ce:	86 df       	rcall	.-244    	; 0x16dc <enc28j60Write>
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
    17d0:	85 e0       	ldi	r24, 0x05	; 5
    17d2:	69 e1       	ldi	r22, 0x19	; 25
    17d4:	83 df       	rcall	.-250    	; 0x16dc <enc28j60Write>
	// TX end
	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
    17d6:	86 e0       	ldi	r24, 0x06	; 6
    17d8:	6f ef       	ldi	r22, 0xFF	; 255
    17da:	80 df       	rcall	.-256    	; 0x16dc <enc28j60Write>
	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
    17dc:	87 e0       	ldi	r24, 0x07	; 7
    17de:	6f e1       	ldi	r22, 0x1F	; 31
    17e0:	7d df       	rcall	.-262    	; 0x16dc <enc28j60Write>
        // Type     ETH.DST
        // ARP      BROADCAST
        // 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
        // in binary these poitions are:11 0000 0011 1111
        // This is hex 303F->EPMM0=0x3f,EPMM1=0x30
	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
    17e2:	88 e3       	ldi	r24, 0x38	; 56
    17e4:	60 eb       	ldi	r22, 0xB0	; 176
    17e6:	7a df       	rcall	.-268    	; 0x16dc <enc28j60Write>
	enc28j60Write(EPMM0, 0x3f);
    17e8:	88 e2       	ldi	r24, 0x28	; 40
    17ea:	6f e3       	ldi	r22, 0x3F	; 63
    17ec:	77 df       	rcall	.-274    	; 0x16dc <enc28j60Write>
	enc28j60Write(EPMM1, 0x30);
    17ee:	89 e2       	ldi	r24, 0x29	; 41
    17f0:	60 e3       	ldi	r22, 0x30	; 48
    17f2:	74 df       	rcall	.-280    	; 0x16dc <enc28j60Write>
	enc28j60Write(EPMCSL, 0xf9);
    17f4:	80 e3       	ldi	r24, 0x30	; 48
    17f6:	69 ef       	ldi	r22, 0xF9	; 249
    17f8:	71 df       	rcall	.-286    	; 0x16dc <enc28j60Write>
	enc28j60Write(EPMCSH, 0xf7);
    17fa:	81 e3       	ldi	r24, 0x31	; 49
    17fc:	67 ef       	ldi	r22, 0xF7	; 247
    17fe:	6e df       	rcall	.-292    	; 0x16dc <enc28j60Write>
        //
        //
	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
    1800:	80 ec       	ldi	r24, 0xC0	; 192
    1802:	6d e0       	ldi	r22, 0x0D	; 13
    1804:	6b df       	rcall	.-298    	; 0x16dc <enc28j60Write>
	// bring MAC out of reset
	enc28j60Write(MACON2, 0x00);
    1806:	81 ec       	ldi	r24, 0xC1	; 193
    1808:	60 e0       	ldi	r22, 0x00	; 0
    180a:	68 df       	rcall	.-304    	; 0x16dc <enc28j60Write>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    180c:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    180e:	82 e8       	ldi	r24, 0x82	; 130
    1810:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1812:	77 9b       	sbis	0x0e, 7	; 14
    1814:	fe cf       	rjmp	.-4      	; 0x1812 <enc28j60Init+0xac>
        // write data
        SPDR = data;
    1816:	82 e3       	ldi	r24, 0x32	; 50
    1818:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    181a:	77 9b       	sbis	0x0e, 7	; 14
    181c:	fe cf       	rjmp	.-4      	; 0x181a <enc28j60Init+0xb4>
        CSPASSIVE;
    181e:	c1 9a       	sbi	0x18, 1	; 24
	// bring MAC out of reset
	enc28j60Write(MACON2, 0x00);
	// enable automatic padding to 60bytes and CRC operations
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
	// set inter-frame gap (non-back-to-back)
	enc28j60Write(MAIPGL, 0x12);
    1820:	86 ec       	ldi	r24, 0xC6	; 198
    1822:	62 e1       	ldi	r22, 0x12	; 18
    1824:	5b df       	rcall	.-330    	; 0x16dc <enc28j60Write>
	enc28j60Write(MAIPGH, 0x0C);
    1826:	87 ec       	ldi	r24, 0xC7	; 199
    1828:	6c e0       	ldi	r22, 0x0C	; 12
    182a:	58 df       	rcall	.-336    	; 0x16dc <enc28j60Write>
	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
    182c:	84 ec       	ldi	r24, 0xC4	; 196
    182e:	62 e1       	ldi	r22, 0x12	; 18
    1830:	55 df       	rcall	.-342    	; 0x16dc <enc28j60Write>
	// Set the maximum packet size which the controller will accept
        // Do not send packets longer than MAX_FRAMELEN:
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
    1832:	8a ec       	ldi	r24, 0xCA	; 202
    1834:	6c ed       	ldi	r22, 0xDC	; 220
    1836:	52 df       	rcall	.-348    	; 0x16dc <enc28j60Write>
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
    1838:	8b ec       	ldi	r24, 0xCB	; 203
    183a:	65 e0       	ldi	r22, 0x05	; 5
    183c:	4f df       	rcall	.-354    	; 0x16dc <enc28j60Write>
	// do bank 3 stuff
        // write MAC address
        // NOTE: MAC address in ENC28J60 is byte-backward
        enc28j60Write(MAADR5, macaddr[0]);
    183e:	84 ee       	ldi	r24, 0xE4	; 228
    1840:	68 81       	ld	r22, Y
    1842:	4c df       	rcall	.-360    	; 0x16dc <enc28j60Write>
        enc28j60Write(MAADR4, macaddr[1]);
    1844:	85 ee       	ldi	r24, 0xE5	; 229
    1846:	69 81       	ldd	r22, Y+1	; 0x01
    1848:	49 df       	rcall	.-366    	; 0x16dc <enc28j60Write>
        enc28j60Write(MAADR3, macaddr[2]);
    184a:	82 ee       	ldi	r24, 0xE2	; 226
    184c:	6a 81       	ldd	r22, Y+2	; 0x02
    184e:	46 df       	rcall	.-372    	; 0x16dc <enc28j60Write>
        enc28j60Write(MAADR2, macaddr[3]);
    1850:	83 ee       	ldi	r24, 0xE3	; 227
    1852:	6b 81       	ldd	r22, Y+3	; 0x03
    1854:	43 df       	rcall	.-378    	; 0x16dc <enc28j60Write>
        enc28j60Write(MAADR1, macaddr[4]);
    1856:	80 ee       	ldi	r24, 0xE0	; 224
    1858:	6c 81       	ldd	r22, Y+4	; 0x04
    185a:	40 df       	rcall	.-384    	; 0x16dc <enc28j60Write>
        enc28j60Write(MAADR0, macaddr[5]);
    185c:	81 ee       	ldi	r24, 0xE1	; 225
    185e:	6d 81       	ldd	r22, Y+5	; 0x05
    1860:	3d df       	rcall	.-390    	; 0x16dc <enc28j60Write>
	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
    1862:	80 e1       	ldi	r24, 0x10	; 16
    1864:	60 e0       	ldi	r22, 0x00	; 0
    1866:	71 e0       	ldi	r23, 0x01	; 1
    1868:	5f df       	rcall	.-322    	; 0x1728 <enc28j60PhyWrite>
	// switch to bank 0
	enc28j60SetBank(ECON1);
    186a:	8f e1       	ldi	r24, 0x1F	; 31
    186c:	08 df       	rcall	.-496    	; 0x167e <enc28j60SetBank>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    186e:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    1870:	8b e9       	ldi	r24, 0x9B	; 155
    1872:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1874:	77 9b       	sbis	0x0e, 7	; 14
    1876:	fe cf       	rjmp	.-4      	; 0x1874 <enc28j60Init+0x10e>
        // write data
        SPDR = data;
    1878:	80 ec       	ldi	r24, 0xC0	; 192
    187a:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    187c:	77 9b       	sbis	0x0e, 7	; 14
    187e:	fe cf       	rjmp	.-4      	; 0x187c <enc28j60Init+0x116>
        CSPASSIVE;
    1880:	c1 9a       	sbi	0x18, 1	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    1882:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    1884:	8f e9       	ldi	r24, 0x9F	; 159
    1886:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1888:	77 9b       	sbis	0x0e, 7	; 14
    188a:	fe cf       	rjmp	.-4      	; 0x1888 <enc28j60Init+0x122>
        // write data
        SPDR = data;
    188c:	84 e0       	ldi	r24, 0x04	; 4
    188e:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1890:	77 9b       	sbis	0x0e, 7	; 14
    1892:	fe cf       	rjmp	.-4      	; 0x1890 <enc28j60Init+0x12a>
        CSPASSIVE;
    1894:	c1 9a       	sbi	0x18, 1	; 24
	enc28j60SetBank(ECON1);
	// enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
}
    1896:	df 91       	pop	r29
    1898:	cf 91       	pop	r28
    189a:	08 95       	ret

0000189c <enc28j60getrev>:

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
	return(enc28j60Read(EREVID));
    189c:	82 e7       	ldi	r24, 0x72	; 114
    189e:	16 df       	rcall	.-468    	; 0x16cc <enc28j60Read>
}
    18a0:	08 95       	ret

000018a2 <enc28j60linkup>:

// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
    18a2:	81 e1       	ldi	r24, 0x11	; 17
    18a4:	2d df       	rcall	.-422    	; 0x1700 <enc28j60PhyReadH>
    18a6:	20 e0       	ldi	r18, 0x00	; 0
    18a8:	89 2b       	or	r24, r25
    18aa:	09 f0       	breq	.+2      	; 0x18ae <enc28j60linkup+0xc>
    18ac:	21 e0       	ldi	r18, 0x01	; 1
}
    18ae:	82 2f       	mov	r24, r18
    18b0:	08 95       	ret

000018b2 <enc28j60PacketSend>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
    18b2:	df 92       	push	r13
    18b4:	ef 92       	push	r14
    18b6:	ff 92       	push	r15
    18b8:	0f 93       	push	r16
    18ba:	1f 93       	push	r17
    18bc:	cf 93       	push	r28
    18be:	df 93       	push	r29
    18c0:	ec 01       	movw	r28, r24
    18c2:	8b 01       	movw	r16, r22

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    18c4:	3f e9       	ldi	r19, 0x9F	; 159
    18c6:	d3 2e       	mov	r13, r19
        waitspi();
        // write data
        SPDR = data;
    18c8:	20 e8       	ldi	r18, 0x80	; 128
    18ca:	f2 2e       	mov	r15, r18

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    18cc:	9f eb       	ldi	r25, 0xBF	; 191
    18ce:	e9 2e       	mov	r14, r25
    18d0:	14 c0       	rjmp	.+40     	; 0x18fa <enc28j60PacketSend+0x48>
{
        // Check no transmit in progress
        while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
        {
                // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
                if( (enc28j60Read(EIR) & EIR_TXERIF) ) {
    18d2:	8c e1       	ldi	r24, 0x1C	; 28
    18d4:	fb de       	rcall	.-522    	; 0x16cc <enc28j60Read>
    18d6:	81 ff       	sbrs	r24, 1
    18d8:	10 c0       	rjmp	.+32     	; 0x18fa <enc28j60PacketSend+0x48>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    18da:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    18dc:	df b8       	out	0x0f, r13	; 15
        waitspi();
    18de:	77 9b       	sbis	0x0e, 7	; 14
    18e0:	fe cf       	rjmp	.-4      	; 0x18de <enc28j60PacketSend+0x2c>
        // write data
        SPDR = data;
    18e2:	ff b8       	out	0x0f, r15	; 15
        waitspi();
    18e4:	77 9b       	sbis	0x0e, 7	; 14
    18e6:	fe cf       	rjmp	.-4      	; 0x18e4 <enc28j60PacketSend+0x32>
        CSPASSIVE;
    18e8:	c1 9a       	sbi	0x18, 1	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    18ea:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    18ec:	ef b8       	out	0x0f, r14	; 15
        waitspi();
    18ee:	77 9b       	sbis	0x0e, 7	; 14
    18f0:	fe cf       	rjmp	.-4      	; 0x18ee <enc28j60PacketSend+0x3c>
        // write data
        SPDR = data;
    18f2:	ff b8       	out	0x0f, r15	; 15
        waitspi();
    18f4:	77 9b       	sbis	0x0e, 7	; 14
    18f6:	fe cf       	rjmp	.-4      	; 0x18f4 <enc28j60PacketSend+0x42>
        CSPASSIVE;
    18f8:	c1 9a       	sbi	0x18, 1	; 24
}

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
        // Check no transmit in progress
        while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
    18fa:	80 e0       	ldi	r24, 0x00	; 0
    18fc:	6f e1       	ldi	r22, 0x1F	; 31
    18fe:	75 de       	rcall	.-790    	; 0x15ea <enc28j60ReadOp>
    1900:	83 fd       	sbrc	r24, 3
    1902:	e7 cf       	rjmp	.-50     	; 0x18d2 <enc28j60PacketSend+0x20>
                        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
                        enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
                }
        }
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
    1904:	82 e0       	ldi	r24, 0x02	; 2
    1906:	6f ef       	ldi	r22, 0xFF	; 255
    1908:	e9 de       	rcall	.-558    	; 0x16dc <enc28j60Write>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
    190a:	83 e0       	ldi	r24, 0x03	; 3
    190c:	69 e1       	ldi	r22, 0x19	; 25
    190e:	e6 de       	rcall	.-564    	; 0x16dc <enc28j60Write>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
    1910:	ce 01       	movw	r24, r28
    1912:	81 50       	subi	r24, 0x01	; 1
    1914:	68 2f       	mov	r22, r24
    1916:	86 e0       	ldi	r24, 0x06	; 6
    1918:	e1 de       	rcall	.-574    	; 0x16dc <enc28j60Write>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
    191a:	9e 01       	movw	r18, r28
    191c:	21 50       	subi	r18, 0x01	; 1
    191e:	36 4e       	sbci	r19, 0xE6	; 230
    1920:	87 e0       	ldi	r24, 0x07	; 7
    1922:	63 2f       	mov	r22, r19
    1924:	db de       	rcall	.-586    	; 0x16dc <enc28j60Write>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    1926:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    1928:	8a e7       	ldi	r24, 0x7A	; 122
    192a:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    192c:	77 9b       	sbis	0x0e, 7	; 14
    192e:	fe cf       	rjmp	.-4      	; 0x192c <enc28j60PacketSend+0x7a>
        // write data
        SPDR = data;
    1930:	1f b8       	out	0x0f, r1	; 15
        waitspi();
    1932:	77 9b       	sbis	0x0e, 7	; 14
    1934:	fe cf       	rjmp	.-4      	; 0x1932 <enc28j60PacketSend+0x80>
        CSPASSIVE;
    1936:	c1 9a       	sbi	0x18, 1	; 24
        CSPASSIVE;
}

void enc28j60WriteBuffer(uint16_t len, uint8_t* data)
{
        CSACTIVE;
    1938:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
    193a:	8a e7       	ldi	r24, 0x7A	; 122
    193c:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    193e:	77 9b       	sbis	0x0e, 7	; 14
    1940:	fe cf       	rjmp	.-4      	; 0x193e <enc28j60PacketSend+0x8c>
    1942:	08 c0       	rjmp	.+16     	; 0x1954 <enc28j60PacketSend+0xa2>
        while(len)
        {
                len--;
                // write data
                SPDR = *data;
    1944:	f8 01       	movw	r30, r16
    1946:	80 81       	ld	r24, Z
    1948:	8f b9       	out	0x0f, r24	; 15
                data++;
                waitspi();
    194a:	77 9b       	sbis	0x0e, 7	; 14
    194c:	fe cf       	rjmp	.-4      	; 0x194a <enc28j60PacketSend+0x98>
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
        {
                len--;
    194e:	21 97       	sbiw	r28, 0x01	; 1
                // write data
                SPDR = *data;
                data++;
    1950:	0f 5f       	subi	r16, 0xFF	; 255
    1952:	1f 4f       	sbci	r17, 0xFF	; 255
{
        CSACTIVE;
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
        waitspi();
        while(len)
    1954:	20 97       	sbiw	r28, 0x00	; 0
    1956:	b1 f7       	brne	.-20     	; 0x1944 <enc28j60PacketSend+0x92>
                // write data
                SPDR = *data;
                data++;
                waitspi();
        }
        CSPASSIVE;
    1958:	c1 9a       	sbi	0x18, 1	; 24
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    195a:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    195c:	8f e9       	ldi	r24, 0x9F	; 159
    195e:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1960:	77 9b       	sbis	0x0e, 7	; 14
    1962:	fe cf       	rjmp	.-4      	; 0x1960 <enc28j60PacketSend+0xae>
        // write data
        SPDR = data;
    1964:	88 e0       	ldi	r24, 0x08	; 8
    1966:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1968:	77 9b       	sbis	0x0e, 7	; 14
    196a:	fe cf       	rjmp	.-4      	; 0x1968 <enc28j60PacketSend+0xb6>
        CSPASSIVE;
    196c:	c1 9a       	sbi	0x18, 1	; 24
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
}
    196e:	df 91       	pop	r29
    1970:	cf 91       	pop	r28
    1972:	1f 91       	pop	r17
    1974:	0f 91       	pop	r16
    1976:	ff 90       	pop	r15
    1978:	ef 90       	pop	r14
    197a:	df 90       	pop	r13
    197c:	08 95       	ret

0000197e <enc28j60hasRxPkt>:

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
	if( enc28j60Read(EPKTCNT) ==0 ){
    197e:	89 e3       	ldi	r24, 0x39	; 57
    1980:	a5 de       	rcall	.-694    	; 0x16cc <enc28j60Read>
    1982:	81 11       	cpse	r24, r1
    1984:	81 e0       	ldi	r24, 0x01	; 1
		return(0);
        }
        return(1);
}
    1986:	08 95       	ret

00001988 <enc28j60PacketReceive>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
    1988:	8f 92       	push	r8
    198a:	9f 92       	push	r9
    198c:	af 92       	push	r10
    198e:	bf 92       	push	r11
    1990:	cf 92       	push	r12
    1992:	df 92       	push	r13
    1994:	ef 92       	push	r14
    1996:	ff 92       	push	r15
    1998:	0f 93       	push	r16
    199a:	1f 93       	push	r17
    199c:	cf 93       	push	r28
    199e:	df 93       	push	r29
    19a0:	5c 01       	movw	r10, r24
    19a2:	4b 01       	movw	r8, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
    19a4:	89 e3       	ldi	r24, 0x39	; 57
    19a6:	92 de       	rcall	.-732    	; 0x16cc <enc28j60Read>
    19a8:	88 23       	and	r24, r24
    19aa:	19 f4       	brne	.+6      	; 0x19b2 <enc28j60PacketReceive+0x2a>
    19ac:	c0 e0       	ldi	r28, 0x00	; 0
    19ae:	d0 e0       	ldi	r29, 0x00	; 0
    19b0:	68 c0       	rjmp	.+208    	; 0x1a82 <enc28j60PacketReceive+0xfa>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (gNextPacketPtr &0xFF));
    19b2:	60 91 17 03 	lds	r22, 0x0317
    19b6:	10 91 18 03 	lds	r17, 0x0318
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	8f de       	rcall	.-738    	; 0x16dc <enc28j60Write>
	enc28j60Write(ERDPTH, (gNextPacketPtr)>>8);
    19be:	81 e0       	ldi	r24, 0x01	; 1
    19c0:	61 2f       	mov	r22, r17
    19c2:	8c de       	rcall	.-744    	; 0x16dc <enc28j60Write>
	// read the next packet pointer
	gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    19c4:	8a e3       	ldi	r24, 0x3A	; 58
    19c6:	60 e0       	ldi	r22, 0x00	; 0
    19c8:	10 de       	rcall	.-992    	; 0x15ea <enc28j60ReadOp>
    19ca:	18 2f       	mov	r17, r24
	gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    19cc:	8a e3       	ldi	r24, 0x3A	; 58
    19ce:	60 e0       	ldi	r22, 0x00	; 0
    19d0:	0c de       	rcall	.-1000   	; 0x15ea <enc28j60ReadOp>
    19d2:	38 2f       	mov	r19, r24
    19d4:	20 e0       	ldi	r18, 0x00	; 0
    19d6:	e1 2e       	mov	r14, r17
    19d8:	ff 24       	eor	r15, r15
    19da:	e2 2a       	or	r14, r18
    19dc:	f3 2a       	or	r15, r19
    19de:	f0 92 18 03 	sts	0x0318, r15
    19e2:	e0 92 17 03 	sts	0x0317, r14
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    19e6:	8a e3       	ldi	r24, 0x3A	; 58
    19e8:	60 e0       	ldi	r22, 0x00	; 0
    19ea:	ff dd       	rcall	.-1026   	; 0x15ea <enc28j60ReadOp>
    19ec:	c8 2e       	mov	r12, r24
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    19ee:	8a e3       	ldi	r24, 0x3A	; 58
    19f0:	60 e0       	ldi	r22, 0x00	; 0
    19f2:	fb dd       	rcall	.-1034   	; 0x15ea <enc28j60ReadOp>
    19f4:	d8 2e       	mov	r13, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    19f6:	8a e3       	ldi	r24, 0x3A	; 58
    19f8:	60 e0       	ldi	r22, 0x00	; 0
    19fa:	f7 dd       	rcall	.-1042   	; 0x15ea <enc28j60ReadOp>
    19fc:	08 2f       	mov	r16, r24
    19fe:	10 e0       	ldi	r17, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
    1a00:	8a e3       	ldi	r24, 0x3A	; 58
    1a02:	60 e0       	ldi	r22, 0x00	; 0
    1a04:	f2 dd       	rcall	.-1052   	; 0x15ea <enc28j60ReadOp>
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
    1a06:	38 2f       	mov	r19, r24
    1a08:	20 e0       	ldi	r18, 0x00	; 0
    1a0a:	20 2b       	or	r18, r16
    1a0c:	31 2b       	or	r19, r17
    1a0e:	27 fd       	sbrc	r18, 7
    1a10:	03 c0       	rjmp	.+6      	; 0x1a18 <enc28j60PacketReceive+0x90>
    1a12:	c0 e0       	ldi	r28, 0x00	; 0
    1a14:	d0 e0       	ldi	r29, 0x00	; 0
    1a16:	10 c0       	rjmp	.+32     	; 0x1a38 <enc28j60PacketReceive+0xb0>
	enc28j60Write(ERDPTH, (gNextPacketPtr)>>8);
	// read the next packet pointer
	gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1a18:	cc 2d       	mov	r28, r12
    1a1a:	d0 e0       	ldi	r29, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1a1c:	9d 2d       	mov	r25, r13
    1a1e:	80 e0       	ldi	r24, 0x00	; 0
    1a20:	c8 2b       	or	r28, r24
    1a22:	d9 2b       	or	r29, r25
        len-=4; //remove the CRC count
    1a24:	c5 01       	movw	r24, r10
    1a26:	01 97       	sbiw	r24, 0x01	; 1
    1a28:	24 97       	sbiw	r28, 0x04	; 4
    1a2a:	8c 17       	cp	r24, r28
    1a2c:	9d 07       	cpc	r25, r29
    1a2e:	08 f4       	brcc	.+2      	; 0x1a32 <enc28j60PacketReceive+0xaa>
    1a30:	ec 01       	movw	r28, r24
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
    1a32:	ce 01       	movw	r24, r28
    1a34:	b4 01       	movw	r22, r8
    1a36:	f6 dd       	rcall	.-1044   	; 0x1624 <enc28j60ReadBuffer>
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (gNextPacketPtr &0xFF));
    1a38:	de 2c       	mov	r13, r14
    1a3a:	8c e0       	ldi	r24, 0x0C	; 12
    1a3c:	6e 2d       	mov	r22, r14
    1a3e:	4e de       	rcall	.-868    	; 0x16dc <enc28j60Write>
	enc28j60Write(ERXRDPTH, (gNextPacketPtr)>>8);
    1a40:	8d e0       	ldi	r24, 0x0D	; 13
    1a42:	6f 2d       	mov	r22, r15
    1a44:	4b de       	rcall	.-874    	; 0x16dc <enc28j60Write>
        // Move the RX read pointer to the start of the next received packet
        // This frees the memory we just read out.
        // However, compensate for the errata point 13, rev B4: enver write an even address!
        if ((gNextPacketPtr - 1 < RXSTART_INIT)
    1a46:	87 01       	movw	r16, r14
    1a48:	01 50       	subi	r16, 0x01	; 1
    1a4a:	10 40       	sbci	r17, 0x00	; 0
    1a4c:	89 e1       	ldi	r24, 0x19	; 25
    1a4e:	0f 3f       	cpi	r16, 0xFF	; 255
    1a50:	18 07       	cpc	r17, r24
    1a52:	30 f0       	brcs	.+12     	; 0x1a60 <enc28j60PacketReceive+0xd8>
                || (gNextPacketPtr -1 > RXSTOP_INIT)) {
                enc28j60Write(ERXRDPTL, (RXSTOP_INIT)&0xFF);
    1a54:	8c e0       	ldi	r24, 0x0C	; 12
    1a56:	6e ef       	ldi	r22, 0xFE	; 254
    1a58:	41 de       	rcall	.-894    	; 0x16dc <enc28j60Write>
                enc28j60Write(ERXRDPTH, (RXSTOP_INIT)>>8);
    1a5a:	8d e0       	ldi	r24, 0x0D	; 13
    1a5c:	69 e1       	ldi	r22, 0x19	; 25
    1a5e:	06 c0       	rjmp	.+12     	; 0x1a6c <enc28j60PacketReceive+0xe4>
        } else {
                enc28j60Write(ERXRDPTL, (gNextPacketPtr-1)&0xFF);
    1a60:	da 94       	dec	r13
    1a62:	8c e0       	ldi	r24, 0x0C	; 12
    1a64:	6d 2d       	mov	r22, r13
    1a66:	3a de       	rcall	.-908    	; 0x16dc <enc28j60Write>
                enc28j60Write(ERXRDPTH, (gNextPacketPtr-1)>>8);
    1a68:	8d e0       	ldi	r24, 0x0D	; 13
    1a6a:	61 2f       	mov	r22, r17
    1a6c:	37 de       	rcall	.-914    	; 0x16dc <enc28j60Write>
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    1a6e:	c1 98       	cbi	0x18, 1	; 24
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    1a70:	8e e9       	ldi	r24, 0x9E	; 158
    1a72:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1a74:	77 9b       	sbis	0x0e, 7	; 14
    1a76:	fe cf       	rjmp	.-4      	; 0x1a74 <enc28j60PacketReceive+0xec>
        // write data
        SPDR = data;
    1a78:	80 e4       	ldi	r24, 0x40	; 64
    1a7a:	8f b9       	out	0x0f, r24	; 15
        waitspi();
    1a7c:	77 9b       	sbis	0x0e, 7	; 14
    1a7e:	fe cf       	rjmp	.-4      	; 0x1a7c <enc28j60PacketReceive+0xf4>
        CSPASSIVE;
    1a80:	c1 9a       	sbi	0x18, 1	; 24
                enc28j60Write(ERXRDPTH, (gNextPacketPtr-1)>>8);
        }
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
    1a82:	ce 01       	movw	r24, r28
    1a84:	df 91       	pop	r29
    1a86:	cf 91       	pop	r28
    1a88:	1f 91       	pop	r17
    1a8a:	0f 91       	pop	r16
    1a8c:	ff 90       	pop	r15
    1a8e:	ef 90       	pop	r14
    1a90:	df 90       	pop	r13
    1a92:	cf 90       	pop	r12
    1a94:	bf 90       	pop	r11
    1a96:	af 90       	pop	r10
    1a98:	9f 90       	pop	r9
    1a9a:	8f 90       	pop	r8
    1a9c:	08 95       	ret

00001a9e <atoi>:
    1a9e:	fc 01       	movw	r30, r24
    1aa0:	88 27       	eor	r24, r24
    1aa2:	99 27       	eor	r25, r25
    1aa4:	e8 94       	clt
    1aa6:	21 91       	ld	r18, Z+
    1aa8:	20 32       	cpi	r18, 0x20	; 32
    1aaa:	e9 f3       	breq	.-6      	; 0x1aa6 <atoi+0x8>
    1aac:	29 30       	cpi	r18, 0x09	; 9
    1aae:	10 f0       	brcs	.+4      	; 0x1ab4 <atoi+0x16>
    1ab0:	2e 30       	cpi	r18, 0x0E	; 14
    1ab2:	c8 f3       	brcs	.-14     	; 0x1aa6 <atoi+0x8>
    1ab4:	2b 32       	cpi	r18, 0x2B	; 43
    1ab6:	39 f0       	breq	.+14     	; 0x1ac6 <atoi+0x28>
    1ab8:	2d 32       	cpi	r18, 0x2D	; 45
    1aba:	31 f4       	brne	.+12     	; 0x1ac8 <atoi+0x2a>
    1abc:	68 94       	set
    1abe:	03 c0       	rjmp	.+6      	; 0x1ac6 <atoi+0x28>
    1ac0:	52 d0       	rcall	.+164    	; 0x1b66 <__mulhi_const_10>
    1ac2:	82 0f       	add	r24, r18
    1ac4:	91 1d       	adc	r25, r1
    1ac6:	21 91       	ld	r18, Z+
    1ac8:	20 53       	subi	r18, 0x30	; 48
    1aca:	2a 30       	cpi	r18, 0x0A	; 10
    1acc:	c8 f3       	brcs	.-14     	; 0x1ac0 <atoi+0x22>
    1ace:	1e f4       	brtc	.+6      	; 0x1ad6 <atoi+0x38>
    1ad0:	90 95       	com	r25
    1ad2:	81 95       	neg	r24
    1ad4:	9f 4f       	sbci	r25, 0xFF	; 255
    1ad6:	08 95       	ret

00001ad8 <strncmp>:
    1ad8:	fb 01       	movw	r30, r22
    1ada:	dc 01       	movw	r26, r24
    1adc:	41 50       	subi	r20, 0x01	; 1
    1ade:	50 40       	sbci	r21, 0x00	; 0
    1ae0:	30 f0       	brcs	.+12     	; 0x1aee <strncmp+0x16>
    1ae2:	8d 91       	ld	r24, X+
    1ae4:	01 90       	ld	r0, Z+
    1ae6:	80 19       	sub	r24, r0
    1ae8:	19 f4       	brne	.+6      	; 0x1af0 <strncmp+0x18>
    1aea:	00 20       	and	r0, r0
    1aec:	b9 f7       	brne	.-18     	; 0x1adc <strncmp+0x4>
    1aee:	88 1b       	sub	r24, r24
    1af0:	99 0b       	sbc	r25, r25
    1af2:	08 95       	ret

00001af4 <__eewr_block>:
    1af4:	a0 e0       	ldi	r26, 0x00	; 0
    1af6:	b0 e0       	ldi	r27, 0x00	; 0
    1af8:	ef e7       	ldi	r30, 0x7F	; 127
    1afa:	fd e0       	ldi	r31, 0x0D	; 13
    1afc:	6a c0       	rjmp	.+212    	; 0x1bd2 <__prologue_saves__+0x14>
    1afe:	ec 01       	movw	r28, r24
    1b00:	7b 01       	movw	r14, r22
    1b02:	8a 01       	movw	r16, r20
    1b04:	69 01       	movw	r12, r18
    1b06:	09 c0       	rjmp	.+18     	; 0x1b1a <__eewr_block+0x26>
    1b08:	ce 01       	movw	r24, r28
    1b0a:	21 96       	adiw	r28, 0x01	; 1
    1b0c:	f7 01       	movw	r30, r14
    1b0e:	61 91       	ld	r22, Z+
    1b10:	7f 01       	movw	r14, r30
    1b12:	f6 01       	movw	r30, r12
    1b14:	09 95       	icall
    1b16:	01 50       	subi	r16, 0x01	; 1
    1b18:	10 40       	sbci	r17, 0x00	; 0
    1b1a:	01 15       	cp	r16, r1
    1b1c:	11 05       	cpc	r17, r1
    1b1e:	a1 f7       	brne	.-24     	; 0x1b08 <__eewr_block+0x14>
    1b20:	cd b7       	in	r28, 0x3d	; 61
    1b22:	de b7       	in	r29, 0x3e	; 62
    1b24:	e8 e0       	ldi	r30, 0x08	; 8
    1b26:	71 c0       	rjmp	.+226    	; 0x1c0a <__epilogue_restores__+0x14>

00001b28 <itoa>:
    1b28:	fb 01       	movw	r30, r22
    1b2a:	9f 01       	movw	r18, r30
    1b2c:	e8 94       	clt
    1b2e:	42 30       	cpi	r20, 0x02	; 2
    1b30:	bc f0       	brlt	.+46     	; 0x1b60 <itoa+0x38>
    1b32:	45 32       	cpi	r20, 0x25	; 37
    1b34:	ac f4       	brge	.+42     	; 0x1b60 <itoa+0x38>
    1b36:	4a 30       	cpi	r20, 0x0A	; 10
    1b38:	29 f4       	brne	.+10     	; 0x1b44 <itoa+0x1c>
    1b3a:	97 fb       	bst	r25, 7
    1b3c:	1e f4       	brtc	.+6      	; 0x1b44 <itoa+0x1c>
    1b3e:	90 95       	com	r25
    1b40:	81 95       	neg	r24
    1b42:	9f 4f       	sbci	r25, 0xFF	; 255
    1b44:	64 2f       	mov	r22, r20
    1b46:	77 27       	eor	r23, r23
    1b48:	26 d0       	rcall	.+76     	; 0x1b96 <__udivmodhi4>
    1b4a:	80 5d       	subi	r24, 0xD0	; 208
    1b4c:	8a 33       	cpi	r24, 0x3A	; 58
    1b4e:	0c f0       	brlt	.+2      	; 0x1b52 <itoa+0x2a>
    1b50:	89 5d       	subi	r24, 0xD9	; 217
    1b52:	81 93       	st	Z+, r24
    1b54:	cb 01       	movw	r24, r22
    1b56:	00 97       	sbiw	r24, 0x00	; 0
    1b58:	a9 f7       	brne	.-22     	; 0x1b44 <itoa+0x1c>
    1b5a:	16 f4       	brtc	.+4      	; 0x1b60 <itoa+0x38>
    1b5c:	5d e2       	ldi	r21, 0x2D	; 45
    1b5e:	51 93       	st	Z+, r21
    1b60:	10 82       	st	Z, r1
    1b62:	c9 01       	movw	r24, r18
    1b64:	08 c0       	rjmp	.+16     	; 0x1b76 <strrev>

00001b66 <__mulhi_const_10>:
    1b66:	7a e0       	ldi	r23, 0x0A	; 10
    1b68:	97 9f       	mul	r25, r23
    1b6a:	90 2d       	mov	r25, r0
    1b6c:	87 9f       	mul	r24, r23
    1b6e:	80 2d       	mov	r24, r0
    1b70:	91 0d       	add	r25, r1
    1b72:	11 24       	eor	r1, r1
    1b74:	08 95       	ret

00001b76 <strrev>:
    1b76:	dc 01       	movw	r26, r24
    1b78:	fc 01       	movw	r30, r24
    1b7a:	67 2f       	mov	r22, r23
    1b7c:	71 91       	ld	r23, Z+
    1b7e:	77 23       	and	r23, r23
    1b80:	e1 f7       	brne	.-8      	; 0x1b7a <strrev+0x4>
    1b82:	32 97       	sbiw	r30, 0x02	; 2
    1b84:	04 c0       	rjmp	.+8      	; 0x1b8e <strrev+0x18>
    1b86:	7c 91       	ld	r23, X
    1b88:	6d 93       	st	X+, r22
    1b8a:	70 83       	st	Z, r23
    1b8c:	62 91       	ld	r22, -Z
    1b8e:	ae 17       	cp	r26, r30
    1b90:	bf 07       	cpc	r27, r31
    1b92:	c8 f3       	brcs	.-14     	; 0x1b86 <strrev+0x10>
    1b94:	08 95       	ret

00001b96 <__udivmodhi4>:
    1b96:	aa 1b       	sub	r26, r26
    1b98:	bb 1b       	sub	r27, r27
    1b9a:	51 e1       	ldi	r21, 0x11	; 17
    1b9c:	07 c0       	rjmp	.+14     	; 0x1bac <__udivmodhi4_ep>

00001b9e <__udivmodhi4_loop>:
    1b9e:	aa 1f       	adc	r26, r26
    1ba0:	bb 1f       	adc	r27, r27
    1ba2:	a6 17       	cp	r26, r22
    1ba4:	b7 07       	cpc	r27, r23
    1ba6:	10 f0       	brcs	.+4      	; 0x1bac <__udivmodhi4_ep>
    1ba8:	a6 1b       	sub	r26, r22
    1baa:	b7 0b       	sbc	r27, r23

00001bac <__udivmodhi4_ep>:
    1bac:	88 1f       	adc	r24, r24
    1bae:	99 1f       	adc	r25, r25
    1bb0:	5a 95       	dec	r21
    1bb2:	a9 f7       	brne	.-22     	; 0x1b9e <__udivmodhi4_loop>
    1bb4:	80 95       	com	r24
    1bb6:	90 95       	com	r25
    1bb8:	bc 01       	movw	r22, r24
    1bba:	cd 01       	movw	r24, r26
    1bbc:	08 95       	ret

00001bbe <__prologue_saves__>:
    1bbe:	2f 92       	push	r2
    1bc0:	3f 92       	push	r3
    1bc2:	4f 92       	push	r4
    1bc4:	5f 92       	push	r5
    1bc6:	6f 92       	push	r6
    1bc8:	7f 92       	push	r7
    1bca:	8f 92       	push	r8
    1bcc:	9f 92       	push	r9
    1bce:	af 92       	push	r10
    1bd0:	bf 92       	push	r11
    1bd2:	cf 92       	push	r12
    1bd4:	df 92       	push	r13
    1bd6:	ef 92       	push	r14
    1bd8:	ff 92       	push	r15
    1bda:	0f 93       	push	r16
    1bdc:	1f 93       	push	r17
    1bde:	cf 93       	push	r28
    1be0:	df 93       	push	r29
    1be2:	cd b7       	in	r28, 0x3d	; 61
    1be4:	de b7       	in	r29, 0x3e	; 62
    1be6:	ca 1b       	sub	r28, r26
    1be8:	db 0b       	sbc	r29, r27
    1bea:	0f b6       	in	r0, 0x3f	; 63
    1bec:	f8 94       	cli
    1bee:	de bf       	out	0x3e, r29	; 62
    1bf0:	0f be       	out	0x3f, r0	; 63
    1bf2:	cd bf       	out	0x3d, r28	; 61
    1bf4:	09 94       	ijmp

00001bf6 <__epilogue_restores__>:
    1bf6:	2a 88       	ldd	r2, Y+18	; 0x12
    1bf8:	39 88       	ldd	r3, Y+17	; 0x11
    1bfa:	48 88       	ldd	r4, Y+16	; 0x10
    1bfc:	5f 84       	ldd	r5, Y+15	; 0x0f
    1bfe:	6e 84       	ldd	r6, Y+14	; 0x0e
    1c00:	7d 84       	ldd	r7, Y+13	; 0x0d
    1c02:	8c 84       	ldd	r8, Y+12	; 0x0c
    1c04:	9b 84       	ldd	r9, Y+11	; 0x0b
    1c06:	aa 84       	ldd	r10, Y+10	; 0x0a
    1c08:	b9 84       	ldd	r11, Y+9	; 0x09
    1c0a:	c8 84       	ldd	r12, Y+8	; 0x08
    1c0c:	df 80       	ldd	r13, Y+7	; 0x07
    1c0e:	ee 80       	ldd	r14, Y+6	; 0x06
    1c10:	fd 80       	ldd	r15, Y+5	; 0x05
    1c12:	0c 81       	ldd	r16, Y+4	; 0x04
    1c14:	1b 81       	ldd	r17, Y+3	; 0x03
    1c16:	aa 81       	ldd	r26, Y+2	; 0x02
    1c18:	b9 81       	ldd	r27, Y+1	; 0x01
    1c1a:	ce 0f       	add	r28, r30
    1c1c:	d1 1d       	adc	r29, r1
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	f8 94       	cli
    1c22:	de bf       	out	0x3e, r29	; 62
    1c24:	0f be       	out	0x3f, r0	; 63
    1c26:	cd bf       	out	0x3d, r28	; 61
    1c28:	ed 01       	movw	r28, r26
    1c2a:	08 95       	ret

00001c2c <_exit>:
    1c2c:	f8 94       	cli

00001c2e <__stop_program>:
    1c2e:	ff cf       	rjmp	.-2      	; 0x1c2e <__stop_program>
