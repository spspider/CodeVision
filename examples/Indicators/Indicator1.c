#include "iom16.h"
#define a 1   // Эти макросы содержат числа, соответствующие двойке,
#define b 2   // возведенной в степень, равной номеру "ножки" того
#define c 4   // порта, к которому подключен сегмент индикатора с
#define d 128 // одноименным макросу названием. Для того, чтобы вывести
#define e 64  // какую-либо цифру на индикатор, нужно отправить в порт
#define f 32  // число 255 минус сумму соответствующих сегментам макросов.
#define g 16  // Эти числа позволяют сделать программу независимой от подключения.
#define DP 8  // Измените эти числа, если индикатор выводит букву "зю"

short unsigned int i = 1;
unsigned char DigNumber = 0;
unsigned char Dig[10]; // Массив, в котором хранятся числа, которые нужно
// вывести через порт на индикатор, чтобы он показал цифру, равную номеру
// элемента массива. Числа зависят только от макросов.

void io_init()
{
  DDRD = 0xFF;  // К порту D подключен индикатор
  PORTD = 0xFF;
}

void timer0_init()
{
  OCR0 = 15;  // Таймер срабатывает каждые 1024 такта. Прерывание каждые
  // 1024*16 тактов.
  TCCR0 |= (1 << WGM01) | (1 << CS00) | (1 << CS02);
  TIMSK |= (1 << OCIE0);
}

void Dig_init()
{
  Dig[0] = 255 - (a+b+c+d+e+f);   // Если индикатор с общим анодом,
  Dig[1] = 255 - (b+c);           // нужно сумму макросов отнять от
  Dig[2] = 255 - (a+b+g+e+d);     // 255. Если с общим катодом, то
  Dig[3] = 255 - (a+b+g+c+d);     // отнимать не нужно.
  Dig[4] = 255 - (f+g+b+c);       // Имена макросов соответствуют
  Dig[5] = 255 - (a+f+g+c+d);     // именам сегментов индикатора
  Dig[6] = 255 - (a+f+g+c+d+e);
  Dig[7] = 255 - (a+b+c);
  Dig[8] = 255 - (a+b+c+d+e+f+g);
  Dig[9] = 255 - (a+b+c+d+f+g);
}

void main()
{
  io_init();
  timer0_init();
  Dig_init();
  SREG |= (1 << 7);
  PORTD = Dig[0];   //Выводим на индикатор цифру "0"
  while(1)
  {}
}

#pragma vector = TIMER0_COMP_vect
__interrupt void Indic_change()
{
  if (i < 675)  // 675*16*1024 = 11,0592 МГц
  {             // Каждую секунду меняется цифра на индикаторе
    i++;
  }
  else
  {
    i = 1;
    if (DigNumber < 9)
      DigNumber++;
    else
      DigNumber = 0;
    PORTD = Dig[DigNumber];
  }
}
